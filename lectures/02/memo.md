# Memo

## イベント駆動

この説明は、マルチスレッドプログラミングの代替手段としてのイベント駆動アーキテクチャについて述べている。従来の並行処理では複数のスレッドを生成して各タスクを独立して処理するが、スレッド生成・切り替え・同期には相当なオーバーヘッドが伴う。特に大量の同時接続を扱うサーバーアプリケーションでは、このコストが性能のボトルネックとなる場合がある。イベント駆動アプローチは、単一スレッド内で複数のアクティビティを明示的にインターリーブ（交互実行）することで、このオーバーヘッドを回避する設計思想である。

イベント駆動システムでは、各アクティビティ（例：個別のクライアントリクエスト）の現在の処理状態を明示的にテーブルやデータ構造として保持する必要がある。システムの中核となる単一のイベントループが継続的に動作し、各アクティビティに対する新しい入力（ソケットからのデータ到着、ファイル読み込み完了、タイマー満了など）を監視する。イベントが発生すると、対応するアクティビティの状態を参照して次のステップを実行し、状態を更新する。この方式により、見かけ上は複数のアクティビティが同時に進行しているような並行性を実現する。Node.jsのイベントループやブラウザのJavaScriptエンジンが典型的な実装例であり、現代的なasync/await構文もこの概念を基盤としている。

イベント駆動アーキテクチャの主要な利点は、I/O待機時間を有効活用した高い並行性の実現と、スレッドオーバーヘッドの完全な排除である。しかし、この手法には重要な制約が存在する。単一スレッドで動作するため、CPU集約的な処理では真の並列実行ができず、マルチコア環境での性能向上は期待できない。また、各アクティビティの状態や進行管理をすべて明示的に記述する必要があるため、従来の同期的なプログラミングモデルと比較して実装・デバッグが困難になる傾向がある。特に複雑な制御フローを持つアプリケーションでは、状態遷移の管理が煩雑になり、コールバック地獄のような問題も発生しうる。このため、イベント駆動モデルはI/O集約的なアプリケーション（Webサーバー、チャットシステムなど）では威力を発揮するが、CPU集約的な処理やマルチコア性能を必要とする場面では適さない設計選択である。

## GoのSync.Mutex、sync.Cond、Sync.WaitGroupについて
