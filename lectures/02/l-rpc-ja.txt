6.5840 2025 講義2: スレッドとRPC

トピック：分散システムの実装
  ... とラボ用Go言語プログラミング
  Goスレッド、ウェブクローラー
  Go RPC

なぜGo？
  スレッドの良いサポート
  便利なRPC
  型安全とメモリ安全
  ガベージコレクション（使用後の解放問題なし）
    スレッド + GCは特に魅力的！
  過度に複雑ではない
  Goは分散システムでよく使用される

チュートリアルの後は、https://golang.org/doc/effective_go.html を使用

スレッド
  有用な構造化ツールだが、扱いが困難な場合がある
  GoではgoroutinesとGo呼ぶ；他の皆はthreadsと呼ぶ

スレッド = 「実行スレッド」
  スレッドは1つのプログラムが多くのことを一度に行うことを可能にする
  各スレッドは非スレッドプログラムと同様にシーケンシャルに実行される
  スレッドはメモリを共有する
  各スレッドはスレッド毎の状態を含む：
    プログラムカウンター、レジスタ、スタック

なぜスレッド？
  I/O並行性
    クライアントは多くのサーバーに並列でリクエストを送信し応答を待つ。
    サーバーは多くの同時クライアントリクエストを処理する。
      各リクエストはブロックする可能性がある。
      クライアントXのためにディスクがデータを読むのを待っている間、
        クライアントYからのリクエストを処理。
  マルチコア性能
    複数のコアで並列にコードを実行。
  利便性
    バックグラウンドで、毎秒1回、各ワーカーがまだ生きているかチェック。

スレッドの代替手段はあるか？
  はい：単一スレッドでアクティビティを明示的にインターリーブするコードを書く。
    通常「イベント駆動」と呼ばれる。
  各アクティビティについて状態のテーブルを保持、例：各クライアントリクエスト。
  1つの「イベント」ループ：
    各アクティビティに対する新しい入力をチェック（例：サーバーからの応答到着）、
    各アクティビティの次のステップを実行、
    状態を更新。
  イベント駆動はI/O並行性を得ることができ、
    スレッドのコスト（相当な場合がある）を排除するが、
    マルチコアスピードアップは得られず、
    プログラムするのが困難。

スレッドの課題：
  データの安全な共有
    2つのスレッドが同時にn = n + 1を行ったら？
      または1つのスレッドが読み、もう1つがインクリメントしたら？
    これは「競合」
      = 2つのスレッドが同時に同じメモリを使用し、一方（または両方）が書き込み
      しばしばバグ
    -> ロック（GoのSync.Mutex）を使用
    -> または変更可能データの共有を避ける
  スレッド間の協調
    1つのスレッドがデータを生産し、もう1つのスレッドがそれを消費
      消費者はどのように待つ（そしてCPUを解放する）か？
      生産者はどのように消費者を起こすか？
    -> Goチャネルやsync.CondやSync.WaitGroupを使用
  デッドロック
    互いを待つスレッドのサイクル
    ロック、チャネル、またはRPCを介して

チュートリアルのウェブクローラーをスレッドの例として見てみよう。

ウェブクローラーとは何か？
  目標：すべてのウェブページを取得、例：インデクサーに供給
  開始ウェブページを与える
  すべてのリンクを再帰的に辿る
  [図：ページ、リンク、DAG、サイクル]
  ただし、与えられたページを1度だけ取得
    サイクルに捕らわれないように

クローラーの課題
  I/O並行性の活用
    ネットワーク遅延はネットワーク容量より制限的
      インターネット遅延：光の速度などで約0.1秒
      インターネットスループット：MB/秒またはGB/秒
    多くのページを並列で取得
      秒あたりの取得URL数を増やすため
    => 並行性にスレッドを使用
  各URLを*1度だけ*取得
    ネットワーク帯域幅の無駄を避ける
    リンクサイクルを避ける
    リモートサーバーに優しく
    => 訪問したURLを記憶する必要
  完了したときを知る

3つの解決策を見る[スケジュールページのcrawler.go]
  シーケンシャル
  並行、共有データによる協調
  並行、チャネルによる協調

シーケンシャルクローラー：
  再帰的なSerial呼び出しによる深度優先探索を実行
  「fetched」マップは繰り返しを避け、サイクルを破る
    単一マップ、参照渡し、呼び出し元は呼び出され先の更新を見る
  すべての[再帰的]リンクが探索されると完了：簡単
  ただし：一度に1ページずつしか取得しない -- 遅い
    Serial()呼び出しの前に単に「go」を置けるか？
    何が起こるか？
    試してみよう... 何が起こったか？

ConcurrentMutexクローラー：
  各ページ取得に対してスレッドを作成
    多くの並行取得、より高い取得率
  「go func」はgoroutineを作成し実行を開始
    func...は「匿名関数」
  スレッドはfs.fetchedマップを共有
    したがって1つのスレッドのみが任意の与えられたページを取得
  testAndSet()でのMutex（Lock()とUnlock()）はなぜ？
    1つの理由：
      2つのスレッドが同じURLでConcurrentMutex()への同時呼び出しを行う
        2つの異なるページが同じURLへのリンクを含むため
      T1がfetched[url]を読み、T2がfetched[url]を読む
      両方ともurlが取得されていないことを確認（fetched[url] = false）
      両方が取得、これは間違い
      mutexは一方を待たせ、他方がチェックとセットの両方を行う
        したがって1つのスレッドのみがfetched[url]==falseを見る
      「ロックがfs.fetched[]を保護する」と言う
        ただしGoはロックとデータ間の関係を強制しない！
      lock/unlockの間のコードは「クリティカルセクション」と呼ばれることが多い
    もう1つの理由：
      内部的に、マップは複雑なデータ構造（ツリー？拡張可能ハッシュ？）
      並行update/updateは内部不変式を破る可能性
      並行update/readは読み込みをクラッシュさせる可能性
    defer...
    Lock() / Unlock()をコメントアウトしたら？
      go run crawler.go
        常に動作する？常に失敗？なぜ？
      go run -race crawler.go
        出力が正しくても競合を検出！
    Unlock()を忘れたら？ デッドロック
  ConcurrentMutexクローラーはどのように完了を決定するか？
    sync.WaitGroup -- 基本的にカウンター
    Wait()はすべてのAdd()がDone()でバランスされるまで待つ
      つまりすべての子スレッドの終了を待つ
    [図：goroutineのツリー、循環URL図に重ねて]
    ツリーの各ノードにWaitGroupがある
  並行スレッドはいくつある可能性があるか？

ConcurrentChannelクローラー
  Goチャネル：
    チャネルはオブジェクト
      ch := make(chan int)
    チャネルは1つのスレッドが別のスレッドにオブジェクトを送信することを可能にする
    ch <- x
      送信者は何らかのgoroutineが受信するまで待つ
    y := <- ch
      受信者は何らかのgoroutineが送信するまで待つ
    また：for y := range ch
    チャネルは通信と同期の両方を行う
    複数のスレッドがチャネルで送受信可能
    send+recvは1マイクロ秒未満 -- かなり安価
    覚えておく：送信者は受信者が受信するまでブロック！
      「同期」
      デッドロックに注意
  ConcurrentChannel coordinator()
    coordinator()は各ページを取得するワーカーgoroutineを作成
    worker()はページのURLのsliceをチャネルで送信
      複数のワーカーが単一チャネルで送信
    coordinator()はチャネルからURLスライスを読み込み
  coordinatorはどの行で待つか？
    coordinatorは待っている間CPUタイムを使用するか？
  注：ここに再帰はない；coordinator()がすべてのワーカーを作成。
  注：fetchedマップをロックする必要はない、共有されていないから！
  coordinatorは完了をどのように知るか？
    nでワーカーの数を保持。
    各ワーカーはチャネルで1つのアイテムを正確に送信。
  チャネルは2つのことを行う：
    1. 値の通信。
    2. イベントの通知（例：スレッド終了）。

複数のスレッドが同じチャネルを使用しても安全なのはなぜ？

これは競合か：
  ワーカースレッドがurlスライスを変更（作成）し、coordinatorがそれを使用？
  * ワーカーは送信*前に*のみスライスに書き込み
  * coordinatorは受信*後に*のみスライスを読み込み
  したがって同時にスライスを使用することはできず、競合はない。

なぜConcurrentChannel()は「ch <- ...」のためだけにgoroutineを作成するのか？
  goroutineを取り除いてみよう...

共有とロックを使うか、チャネルを使うか？
  ほとんど（すべて？）の問題はどちらのスタイルでも解決可能
  最も意味があるのはプログラマーがどう考えるかに依存
    状態 -- 共有とロック
    通信 -- チャネル
  6.824ラボについては、状態には共有+ロック、
    待機/通知にはsync.CondやチャネルやTime.Sleep()を推奨。

リモートプロシージャコール（RPC）
  分散システムの重要な部品；すべてのラボでRPCを使用
  目標：簡単にプログラムできるクライアント/サーバー通信
  ネットワークプロトコルの詳細を隠す
  データ（文字列、配列、マップなど）を「ワイヤフォーマット」に変換
  移植性/相互運用性

RPCメッセージ図：
  クライアント          サーバー
    リクエスト--->
       <---レスポンス

ソフトウェア構造
  クライアントアプリ    ハンドラー関数
   スタブ関数          ディスパッチャー
   RPCライブラリ       RPCライブラリ
     ネット ------------ ネット

Go例：スケジュールページのkv.go
  おもちゃのキー/値ストレージサーバー -- Put(key,value)、Get(key)->value
  GoのRPCライブラリを使用
  共通：
    各サーバーハンドラーに対してArgsとReply structを宣言。
  クライアント：
    connect()のDial()がサーバーへのTCP接続を作成
    get()とput()はクライアント「スタブ」
    Call()がRPCライブラリに呼び出しを実行するよう要求
      接続、関数名、引数、応答を置く場所を指定
      ライブラリが引数をマーシャル、リクエスト送信、待機、応答をアンマーシャル
      Call()からの戻り値は応答を得たかを示す
      通常reply.Errもサービスレベル故障を示す
  サーバー：
    GoはサーバーがRPCハンドラーとしてのメソッドを持つオブジェクトを宣言することを要求
    サーバーはその後そのオブジェクトをRPCライブラリに登録
    サーバーはTCP接続を受け入れ、RPCライブラリに渡す
    RPCライブラリ
      各リクエストを読み込み
      このリクエストに対して新しいgoroutineを作成
      リクエストをアンマーシャル
      名前付きオブジェクトを検索（Register()で作成されたテーブル内）
      オブジェクトの名前付きメソッドを呼び出し（ディスパッチ）
      応答をマーシャル
      TCP接続に応答を書き込み
    サーバーのGet()とPut()ハンドラー
      RPCライブラリが各リクエストに対して新しいgoroutineを作成するのでロック必須
      引数を読み；応答を変更

詳細：
  バインディング：クライアントはどのサーバーコンピュータと話すか知るか？
    GoのRPCについては、サーバー名/ポートはDialの引数
    大規模システムには何らかの名前または設定サーバーがある
  マーシャリング：データをパケットにフォーマット
    GoのRPCライブラリは文字列、配列、オブジェクト、マップなどを渡せる
    Goはポイントされたデータをコピーすることでポインタを渡す
    チャネルや関数は渡せない
    エクスポートされたフィールドのみマーシャル（つまり大文字のフィールド）

RPC問題：故障に対して何をするか？
  例：失われたパケット、壊れたネットワーク、遅いサーバー、クラッシュしたサーバー

クライアントRPCライブラリには故障はどのように見えるか？
  クライアントはサーバーからの応答を見ることがない
  クライアントはサーバーがリクエストを見たか*知らない*！
    [様々な点での損失の図]
    サーバーがリクエストを見なかった可能性
    サーバーが実行したが、応答送信直前にクラッシュした可能性
    サーバーが実行したが、応答配信直前にネットワークが死んだ可能性
  リモートプロシージャコールは単一マシンでのプロシージャコールと同じ動作をしない！
    分散システム実装における繰り返し現れる課題

最もシンプルな故障処理スキーム：「ベストエフォートRPC」
  Call()はしばらく応答を待つ
  何も到着しなければ、リクエストを再送信
  これを数回行う
  その後諦めてエラーを返す

Q：「ベストエフォート」はアプリケーションが対処するのに簡単か？

特に悪い状況：
  クライアントが実行
    Put("k", 10);
    Put("k", 20);
  両方成功
  Get("k")は何を返すか？
  [図、タイムアウト、再送、元のが遅れて到着]

Q：ベストエフォートは問題ないか？
   読み込み専用操作
   繰り返しても無害な操作
     例：DBがレコードが既に挿入されているかチェック

その他の共通セマンティクス：at-most-once
  例えば、Go RPCは「at-most-once」の単純な形
    TCP接続を開く
    TCP接続にリクエストを書き込み
    Go RPCはリクエストを再送信することはない
      したがってサーバーは重複リクエストを見ない
    Go RPCコードは応答を得られなければエラーを返す
      おそらくタイムアウト後（TCPから）
      おそらくサーバーがリクエストを見なかった
      おそらくサーバーがリクエストを処理したが応答が戻る前にサーバー/ネットが故障
  ラボでat-most-onceを実装する他の方法を探る
    レプリケートサーバーには再試行なしは制限的すぎ
    最初のレプリカが故障したら別のレプリカで再試行したい
