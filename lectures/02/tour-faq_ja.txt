Go FAQ

Q: 6.5840がラボにGoを使うのはなぜですか？

A: 数年前まで6.5840はC++を使用していて、うまく機能していました。Goが6.5840ラボにいくらかうまく機能するのは、いくつかの理由があります。Goはガベージコレクションされ型安全で、一般的なバグのクラスを排除します。Goはスレッド（goroutine）の良いサポートと優れたRPCパッケージを持ち、これらは6.5840で直接有用です。スレッドとガベージコレクションは特によく連携します。ガベージコレクションは、オブジェクトを使用する最後のスレッドがいつそれを使用しなくなったかをプログラマーが決定する労力を排除できるからです。6.5840ラボでもおそらくうまく機能するであろう、Javaなどのこれらの機能を持つ他の言語もあります。

Q: 効果的なGoコードを書くための直感を構築するためのコツ/秘訣はありますか？

A: Goコードを書き、他の人のgoコードを読むことで経験を積んでください。このページには多くの有用なコツがあります：https://go.dev/doc/effective_go

Q: goroutineは並列で実行されますか？性能を向上させるために使用できますか？

A: Goのgoroutineは他の言語のスレッドと同じです。Goランタイムは利用可能なすべてのコアでgoroutineを並列実行します。実行可能なgoroutineよりもコアが少ない場合、ランタイムはgoroutine間でコアをプリエンプティブにタイムシェアします。

Q: Goチャネルはどのように機能しますか？Goは多くの可能なgoroutine間でそれらが同期されることをどのように確実にしますか？

A: https://golang.org/src/runtime/chan.go でソースを見ることができますが、追跡するのは簡単ではありません。

高レベルでは、chanはバッファとロックを保持する構造体です。チャネルでの送信は、ロックの取得、何かのスレッドが受信するまで待機（おそらくCPUを解放）、メッセージの受け渡しを含みます。受信は、ロックの取得と送信者の待機を含みます。Go sync.MutexとSync.Condで独自のチャネルを実装できます。

Q: 私は別のgoroutineを起こすためにチャネルを使用していて、チャネルでダミーのboolを送信しています。しかし、その他のgoroutineがすでに実行中の場合（つまりチャネルで受信していない）、送信goroutineがブロックします。何をすべきでしょうか？

A: チャネルではなく条件変数（GoのSync.Cond）を試してください。条件変数は、何かを待っている（または待っていない）可能性があるgoroutineに警告するのによく機能します。チャネルは同期なので、チャネルの他端で待機するgoroutineがあるかどうか確実でない場合は扱いにくいです。

Q: goroutineが複数の異なるチャネルの任意の1つからの入力を待つにはどうすればよいですか？任意の1つのチャネルで受信しようとすると、読むものがなければブロックし、他のチャネルをチェックできません。

A: 各チャネルに対して別々のgoroutineを作成し、各goroutineをそのチャネルでブロックしてみてください。それは常に可能ではありませんが、機能するときは最もシンプルなアプローチです。

そうでなければGoのselectを試してください。

Q: sync.WaitGroupをチャネルではなくいつ使うべきか？その逆は？

A: WaitGroupはかなり特化されています；多数のアクティビティの完了を待つときにのみ有用です。チャネルはより汎用的です；例えば、チャネル上で値を通信できます。WaitGroupよりも数行多くのコードが必要ですが、チャネルを使用して複数のgoroutineを待つことができます。

Q: 私のコードが毎秒1回タスクを実行する必要があります。それを行う最も簡単な方法は何ですか？

A: その定期的なタスクに専用のgoroutineを作成してください。それはtime.Sleep()を使って1秒間停止し、その後タスクを実行し、その後time.Sleep()にループして戻るループを持つべきです。

Q: goroutineを起動するオーバーヘッドがそれらから得る並行性を超える時をどのように知るのですか？

A: 状況によります！あなたのマシンが16コアを持ち、CPU並列性を求めているなら、およそ16の実行可能なgoroutineを持つべきです。ウェブページを取得するのに0.1秒のリアルタイムがかかり、ネットワークが毎秒100のウェブページを転送可能なら、すべてのネットワーク容量を使うためには約10のgoroutineが同時に取得する必要があります。実験的に、goroutineの数を増やすにつれて、しばらくは増加したスループットを見て、その後より多くのスループットを得ることを止めます；その時点で性能の観点から十分なgoroutineを持っています。

Q: インターネット上で接続するGoチャネルをどのように作成するのですか？メッセージ送信に使用するプロトコルをどのように指定するのですか？

A: Goチャネルは単一プログラム内でのみ機能します；チャネルは他のプログラムや他のコンピュータと話すために使用できません。

インターネット上で他のGoプログラムと話すことを可能にするGoのRPCパッケージを見てください：

  https://golang.org/pkg/net/rpc/

Q: 知っておくべき重要/有用なGo特有の並行性パターンは何ですか？

A: このトピックについてのスライドデッキです、Go専門家による：

https://talks.golang.org/2012/concurrency.slide

Q: スライスはどのように実装されますか？

A: スライスは、配列へのポインタと、その配列への開始と終了インデックスを含むオブジェクトです。この配置により、複数のスライスが基盤配列を共有し、各スライスはおそらく配列要素の異なる範囲を露出することを可能にします。

より拡張された議論はこちらです：

  https://blog.golang.org/go-slices-usage-and-internals

私はスライスをよく使用し、配列は決して使いません。Go配列のサイズはその型の一部であるのに対して、引数としてスライスを取る関数は任意の長さのスライスを取ることができるので、GoスライスはGo配列よりも柔軟です。

Q: 人々がGoに使用する一般的なデバッグツールは何ですか？

A: fmt.Printf()

私の知る限り、Goに素晴らしいデバッガーはありませんが、gdbを機能させることができます：

https://golang.org/doc/gdb

いずれにしても、ほとんどのバグについて、fmt.Printf()を非常に効果的なデバッグツールと見つけています。

Q: 同期RPC呼び出しを使用するのが正しいときと、非同期RPC呼び出しを使用するのが正しいときは？

A: ほとんどのコードは続行する前にRPC応答が必要です；その場合は同期RPCを使用するのが理にかなっています。

しかし、クライアントが多くの並行RPCを起動したい場合があります；その場合は非同期の方が良いかもしれません。またはクライアントがRPCの完了を待つ間に他の作業を行いたい場合、おそらくサーバーが遠い（したがって光速時間が高い）ためか、サーバーが到達不能でRPCが長いタイムアウト期間を被る可能性があるためです。

私はGoで非同期RPCを使用したことがありません。RPCを送信したいが結果を待つ必要がない場合、goroutineを作成し、goroutineに同期Call()を実行させます。

Q: Goは産業界で使用されていますか？

A: はい。異なるプログラミング言語がどの程度使用されているかの推定をここで見ることができます：

https://www.tiobe.com/tiobe-index/

Q: 開発者がGoを始めるときに直面する一般的な問題は何ですか？

A: いくつかあります：

- 並行アクセスがあるときにマップをロックで保護しない。Goの競合検出器を使用してください！

- チャネルでのデッドロック。

- goroutineを作成するときに変数をキャプチャしない。

- goroutineをリーク。

Q: Goは継承をサポートしていますか？（Java/C++の「extends」のような方法で？）

A: GoはC++スタイルの継承をサポートしていませんが、ジェネリクス、インターフェース、埋め込み構造体があり、C++で継承を使用する多くのことを行うことを可能にします。

Q: Goチュートリアルで最も混乱したことは、メインスレッドが完了した後にgoroutineが実行を継続しないということでした。これはチュートリアルのどこにも明示的に言及されていないと思います；クローラー演習をデバッグすることで理解しました。

A: はい、チュートリアルにはないと思いますが、言語仕様は明示的です：https://golang.org/ref/spec（Program executionを参照）。

Q: 値レシーバーとポインタレシーバーをいつ選ぶかについてまだ少し混乱しています。どちらかを選ぶときの具体的な/現実世界の例を提供できますか？

A: レシーバーの状態を変更したいときは、ポインタレシーバーを使う必要があります。構造体が非常に大きい場合、値レシーバーはコピーで動作するので、おそらくポインタレシーバーを使いたいでしょう。どちらも適用されない場合は、値レシーバーを使用できます。しかし、値レシーバーには注意してください；例えば、構造体にmutexがある場合、mutexがコピーされ、その目的を無効にするため、値レシーバーにすることはできません。