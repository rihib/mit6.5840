6.5840 2025 第4回講義: 一貫性、線形化可能性

今日のトピック: 一貫性モデル、特に線形化可能性

ストレージを独立したサービスとして持つことが非常に一般的
  計算とストレージが分離され、RPCで通信
  [簡単な図]
  例：ウェブサイトアプリケーションロジック vs データベース
  例：MapReduce vs GFS

分散ストレージの正しい動作について推論できる必要がある
  例：GFSやLab 2からアプリケーションプログラマーが期待できること
  一部は個々のリクエストが何をすべきかについて
  今日：並行クライアントがどのように相互作用すべきか
  -->> 一貫性モデル

一貫性モデルとは何か?
  サービスに対する異なるクライアントの見方の関係性の仕様
  ネットワーククライアントを持つキー/値ストレージに焦点を当てる
    put(k, v) -> <done>
    get(k) -> v
  いくつかのput/get呼び出しが与えられた時、どの結果が有効か?

通常の逐次プログラミングでは、話すことは何もない:
  読み取りが最後に書き込まれた値を返すことを期待する

何が正しいかについて疑問が生じる可能性があるのはいつか?
  [簡単なクライアント/サーバー図]
  書き込みと並行する読み取り
  レプリカ
  キャッシュ
  障害、復旧
  失われたメッセージ
  再送信

ストレージシステムが明示的な一貫性モデルを必要とするのはなぜか?
  アプリケーションにとって、ストレージからの保証なしに正しくあることは困難
    例：プロデューサーが計算してから実行
      put("result", 27)
      put("done", true)
    コンシューマーが実行
      while get("done") == false:
        pause
      v = get("result")
    vが27であることは保証されるか?
  サービスにとって、仕様なしに設計/実装/最適化することは困難
    例：クライアントがGFSレプリカから読み取ることは許可されるか
    (プライマリではなく)?

多くの一貫性モデルがある
  アプリケーションプログラマーの生活を簡素化したいという欲求によって
  駆動されることがある
  ストレージパフォーマンスへの欲求によって駆動されることがある
  実装者にとって便利だった動作を記述することがある
  異なる分野からの多くの重複する定義
    例：ファイルシステム、データベース、CPUメモリ
  今日：線形化可能性
  しかし、以下も見る予定:
    結果的一貫性
    因果的一貫性
    フォーク一貫性
    直列化可能性
  駆動力：パフォーマンス/利便性/耐障害性のトレードオフ

線形化可能性
  これは仕様 -- サービスがどのように振る舞わなければならないかの要件
    クライアントの観点から：サービスの外部から
  通常、人々が「強い一貫性」と言うときの意味
    線形化可能性はプログラマーの直感とかなりよく一致する
    しかし多くの最適化を排除する
  Lab 2で線形化可能な キー/値ストアを実装する予定
    そしてLab 4で再び、今度は耐障害性付きで

出発点
  個々の操作が何をするかについての連続仕様があると仮定する
  連続 = 単一のサーバーが操作を一度に一つずつ実行する
  db[]
  put(k, v):
    db[k] = v
    return true
  get(k):
    return db[k]
  ここに驚きはない

並行クライアント操作についてはどうか?
  クライアントがリクエストを送信する;
    ネットワークを横切るのに時間がかかる;
    サーバーが計算し、レプリカと通信し、など;
    応答がネットワークを通じて移動する;
    クライアントが応答を受信する
  その間に他のクライアントが送信/受信/待機する可能性がある!
  そのため連続仕様は直接適用できない
  並行シナリオを記述する方法が必要
    どの結果が許可される/されないかについて話せるように

定義：履歴
  おそらく並行する操作のタイムラインを記述する
  各操作にクライアントの開始時刻と終了時刻がある
    (クライアントがRPCリクエストを送信した時刻と応答を受信した時刻)
    引数と戻り値も同様
  例：
    C1: |-Wx1-| |-Wx2-|
    C2:   |---Rx2---|
  x軸は実時間
    |- はクライアントがリクエストを送信した時刻を示す
    -| はクライアントが応答を受信した時刻を示す
  "Wx1"はput(x, 1)を意味する
  "Rx2"はget(x) -> 2を意味する
  C1がput(x, 1)を送信し、応答を受け取り、put(x, 2)を送信し、応答を受け取った
    書き込みには完了を示す応答がある
  C2がget(x)を送信し、応答=2を受け取った

履歴は実際の実行でクライアントが見たもののトレース
  実行が線形化可能だったかどうかをチェックするために使用される
  設計者が「これは大丈夫だろうか」という思考実験で使用される

定義：履歴が線形化可能であるのは
  * 各操作について、その開始と終了の間の時点を見つけることができ、かつ
  * 履歴の結果値がポイント順での連続実行と同じである場合

例履歴1:
  |--Wx1--| |--Wx2--|
     |----Rx2----|
       |--Rx1--|

この履歴は線形化可能か?
  各操作について線形化ポイントを見つけることができるか?
  いくつかの異なるポイント割り当てを試す必要があるかもしれない
  このポイントの順序がルールを満たす:
    Wx1 Rx1 Wx2 Rx2
  1. 各ポイントが開始と終了の間にある
  2. シーケンスが連続put/get仕様を満たす

注意：どちらの読み取りも1または2を返す可能性があった
  そのため線形化可能性はしばしば複数の異なる結果を許可する
  そのため事前に予測することはできないことが多いが、後でチェックできる

注意：サービスはおそらくそれらのポイントで操作を実行しなかった!
  ここではサービスが内部でどのように動作したかは関係ない
  クライアントに見える結果が何らかのポイント順での実行から
  生じた可能性があるかどうかのみが重要

線形化可能性の定義で何ができるか?
  設計者向け：この最適化は線形化不可能な結果をもたらす可能性があるか?
  プログラマー向け：クライアントとして何を仮定/期待できるか?
  テスト向け：リクエストを生成し、観測された履歴をチェックする

なぜ「線形化可能性」と呼ばれるのか?
  線形化ポイントが並行操作を連続実行に変える -- 「線形」
  したがって、結果が操作の何らかの線形実行と同じという意味で
  「線形化可能」

例2:
  |-Wx1-| |----Wx2----|
    |---Rx2---|
                |-Rx1-|
線形化ポイントのいくつかの割り当てを試せる
  Wx1 Wx2 Rx2 Rx1はどうか?
  "Wx2 Rx1"が連続仕様に適合しないため無効
何かが線形化可能*でない*ことをどう示すか?
  ポイントの割り当てがどれも機能しないことを示す
  つまり、時間ルールまたは値ルールのいずれかを破る
多くの割り当てを排除するためにショートカットを取ることができることが多い
  例：時間によってWx1またはRx2のいずれかが最初に来なければならない
例2では割り当てが機能しない!
  Wx2のポイントはRx2のポイントより前でなければならない
  そのためWx2のポイントもRx1のポイントより前
  そのため2番目の読み取りが不可能な値を取得した
したがって、システムがこの履歴を生成できる場合、そのシステムが
線形化可能でないことがわかる：バグがあるか、線形化可能性を約束したことがない
Rx2がなかった場合、Rx1は*合法*だっただろう
  読み取り（書き込みと同様）は将来何が合法かに影響を与える可能性がある
そのため、線形化可能性が必要な場合:
  読み取りが書き込みを見つけたら、厳密に後続のすべての読み取りもそれを
  見なければならない
    スプリットブレインを排除
  明らかになった書き込みを忘れることはできない
    例：クラッシュによるデータの忘却を排除

GFSは線形化可能でない：例2の履歴を生成できるため
  Rx1はまだ更新されていないレプリカから来る可能性がある
  GFSを線形化可能にしたい場合、
    一つのアプローチはクライアントの読み取りもプライマリを通すこと
    より遅くなる!

例3:
|--Wx0--|  |--Wx1--|
            |--Wx2--|
         |-Rx2-| |-Rx1-|
これは線形化不可能に見えるかもしれない、なぜなら
  Rx2が2番目の読み取りにも2を見ることを強制するように
  見えるかもしれないから
しかしこの順序は線形化可能であることを示す：Wx0 Wx2 Rx2 Wx1 Rx1
そのため:
  サービスは並行書き込みのどちらの順序でも選択できる
  線形順序は開始時刻または終了時刻順序と異なる可能性がある!

例4:
|--Wx0--|  |--Wx1--|
            |--Wx2--|
C1:      |-Rx2-| |-Rx1-|
C2:      |-Rx1-| |-Rx2-|
連続順序があり得るか?
  C1にはWx2 Rx2 Wx1 Rx1が必要
  C2にはWx1 Rx1 Wx2 Rx2が必要
  Wx2がWx1より前、かつWx2がWx1より後の両方を持つことはできない
  そのため線形化可能でない
そのため:
  サービスは並行書き込みのどちらの順序でも選択できる
  しかしすべてのクライアントが書き込みを同じ順序で見なければならない
  これはレプリカやキャッシュがある場合に重要
    それらすべてが同じ順序で操作を実行しなければならない

例5:
|-Wx1-|
        |-Wx2-|
                |-Rx1-|
順序は不可能 -- 線形化不可能
そのため:
  読み取りは新鮮なデータを返さなければならない：線形化可能性は古い読み取りを
  排除する
  読み取り者が書き込みについて知らなくても
    時間ルールは読み取りが最新のデータを返すことを要求する
  再び、キャッシュとレプリケーションの使用に影響

線形化可能性は多くの魅力的な設計可能性/間違いを禁止する:
  スプリットブレイン（2つのアクティブリーダー）
  クラッシュ+再起動後の完了した書き込みの忘却
  遅れたレプリカや期限切れキャッシュからの読み取り

例6:
[クライアント/ネットワーク/サーバー図]
C1がput(x, 1)を送信
C2がput(x, 2)を送信
サービスがC1のリクエストを受信;
  ネットワークが応答をドロップ;
  C1のRPCライブラリがリクエストを再送信
サービスがC1のリクエストメッセージの*両方*を実行することは合法か?
C3が3回読み取る場合、以下が見える可能性がある:
C1: |--------Wx1---------| (再送信による)
C2:        |-Wx2-|
C3:   |-Rx1-| |-Rx2-|  |-Rx1-|
xは最初0であると仮定
この履歴は線形化可能でない!
そのため、線形化可能性が必要な場合:
  再送信からの重複リクエストは抑制されなければならない!
  Lab 2...

線形化可能システムは読み取りと書き込み操作だけに限定されない
  インクリメント
  追加
  テストアンドセット（ロックを実装するため）
  サーバー状態に対するあらゆる操作

アプリケーションプログラマーは線形化可能性を好む -- 比較的使いやすい:
  * 読み取りが新鮮なデータを見る -- 古くない
  * すべてのクライアントが同じデータを見る（書き込みがない場合）
  * すべてのクライアントがデータ変更を同じ順序で見る
    そのためput(v,27); put(done,true);の例が機能する
  これらの利点は、より弱い一貫性を見るときにより明確になる

線形化可能性をどう実装できるか?
  どの程度のレプリケーション、キャッシュ、耐障害性が必要かによる

クラッシュしない単一連続サーバー
  [図：クライアント、サーバー、操作キュー、状態]
  サーバーが並行して到着するクライアントリクエストの順序を選択
  それらを一度に一つずつその順序で実行し、
    次を開始する前に各々に応答
  重複リクエスト抑制付き

注意：サーバーは履歴、線形化ポイント、または並行性について
推論する必要がない

線形化可能性より強い一貫性を持てるか?
  最近*完了した*putを取得が見るのはどうか?
  そのためここではRx2を保証し、Rx1は決してない:
  C1: |---Wx1---|
  C2:    |---Wx2---|
  C3:                |--Rx2--|
  そしてここではRx1を保証し、Rx2は決してない:
  C1: |---Wx1---|
  C2:    |---Wx2---|
  C3:             |--Rx1--|
  そのような保証は困難だろう:
    サーバーは操作がクライアントで完了する時期を簡単に知ることができない
  線形化可能性はサーバーにとって良い、なぜなら
    並行操作の順序付けの自由度を許可するから

高可用性が必要な場合はどうか?

プライマリ/バックアップレプリケーション
  [図：プライマリ、2つのバックアップ]
  すべてのリクエストがプライマリに行く
    連続順序を選択
    バックアップに転送
    バックアップが同じ順序で実行
    両方のバックアップが実行した後でのみプライマリがクライアントに応答
    そのため、クライアントが応答を見た場合、すべてのバックアップが
    実行したことが保証される
      プライマリが失敗した場合に重要
      完了したリクエストを忘れることを避けるため
  クライアントはGFSのようにバックアップに直接読み取りを送信できない
    C1が新しい値を見て、その後C1が古い値を見る可能性がある
  バックアップがいつ引き継ぐべきかを決定する外部パーティが必要
    スプリットブレインを避けるため
    例：VMware FTでの共有ディスクでのアトミックテストアンドセット、
    またはGFSコーディネーター

線形化可能システムのパフォーマンスについてはどうか?
  悪いニュース：連続側面により並列スピードアップを得ることが困難
  悪いニュース：レプリケーションがある場合、多くの通信と待機
  悪いニュース：レプリケーションがある場合、レプリカが到達可能でなければならず、
            耐障害性が制限される
  良いニュース：キーでシャードできる

他の一貫性モデルについてはどうか?
  より良いパフォーマンスを許可できるか?
  直感的なセマンティクスを持つか?

例：結果的一貫性 -- 弱いモデル
  データの複数のコピー（例：異なるデータセンターに、速度のため）
  読み取りは任意のレプリカを参照（例：最も近い）
  書き込みは任意のレプリカを更新（例：最も近い）
    レプリカクライアントはその1つの更新が完了したときに応答を送信
  レプリカはバックグラウンドで更新を同期
    最終的に、他のレプリカが私の更新を見ることになる

結果的一貫性はかなり人気
  線形化可能性より高速
    特にレプリカが耐障害性のために異なる都市にある場合
  そしてより利用可能 -- 任意の1つのレプリカで十分
    プライマリ/バックアップ通信を待つ必要がない
  AmazonのDynamo; Cassandra; GFS

しかし結果的一貫性はアプリケーションプログラマーにいくつかの異常を公開する:
  * 読み取りが最新の書き込みを見ない可能性がある -- 読み取りが古いデータを
    見る可能性がある
    パスワード変更、ACL変更の問題
  * 書き込みが順序通りでなく現れる可能性がある
    私のresult/doneの例を壊す
  * 異なるクライアントが異なるデータを見る可能性がある
  * 同じアイテムへの並行書き込みは何らかの方法で解決される必要がある!
    C1: put(x, 1)
    C2: put(x, 2)
    最初は異なるレプリカで適用される可能性がある
    後で他のレプリカにプッシュされる
    並行する新しい値をどうマージするか?
    すべてのレプリカが同じ最終値を選択することをどう保証するか?
      最終的に、それらが同一になるように?
  * 結果的一貫性は例えばテストアンドセットをサポートできない

一般的なパターン：通常、これらのうち1つだけを選択できる:
  強い一貫性
  最大可用性

しかし両方ではない
  強い一貫性はレプリカを更新するために待機を強制し、
    あまりに多くのレプリカが利用できない場合は進行できない
    したがって可用性が低い
  結果的一貫性は他のレプリカが到達不可能でも進行できる
    しかし一貫性が低い

---

https://jepsen.io/consistency/models