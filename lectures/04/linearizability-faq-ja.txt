Q: 線形化可能性とは何ですか？

A: 線形化可能性は、並行クライアントリクエストに直面したときにサービスが
どのように振る舞うかについて正しさを定義する一つの方法です。大まかに言えば、
サービスがクライアント操作を到着順に一度に一つずつ実行するように
見えるべきであることを指定します。

線形化可能性は「履歴」で定義されます：クライアント操作のトレースで、
クライアントが各操作を開始する時刻と、クライアントが操作が完了したことを
見る時刻で注釈されます。線形化可能性は、個々の履歴が合法かどうかを
伝えます；サービスが生成できるすべての履歴が線形化可能である場合、
そのサービスは線形化可能であると言えます。

履歴には、クライアントが操作を開始するイベントと、クライアントが操作が
完了したと判断するイベントの2つがあります。したがって、履歴は
クライアント間の並行性とネットワーク遅延を明示的にします。通常、
開始と終了イベントは、サーバーと交換されるリクエストと
レスポンスメッセージに対応します。

履歴が線形化可能であるのは、各操作に「線形化ポイント」（時刻）を
割り当てることができ、各操作のポイントがその開始イベントと終了イベントの
時刻の間にあり、履歴の応答値がポイント順序で操作を一度に一つずつ
実行した場合に得られるものと同じである場合です。線形化ポイントの
割り当てがこれら2つの要件を満たさない場合、履歴は線形化可能ではありません。

線形化可能性の重要な結果は、サービスが並行（時間的に重複する）操作を
実行する順序において自由度を持つことです。特に、クライアントC1とC2からの
操作が並行である場合、C1がC2より前に開始したとしても、サーバーは
C2の操作を最初に実行できます。一方、C1がC2が開始する前に終了した場合、
線形化可能性はサービスがC1の操作をC2の操作より前に実行したかのように
動作することを要求します（つまり、C2の操作はC1の操作の効果を
観測する必要があります）。

----------

Q: 線形化可能性チェッカーはどのように動作しますか？

A: 単純な線形化可能性チェッカーは、線形化可能性の定義のルールに従って
有効かどうかを確認するために、可能なすべての順序（または線形化ポイントの
選択）を試します。大きな履歴では遅すぎるため、賢いチェッカーは
明らかに不可能な順序を見ることを避け（例：提案された線形化ポイントが
操作の開始時刻より前の場合）、可能な場合に個別にチェックできる
サブ履歴に履歴を分解し、より可能性の高い順序を最初に試すための
ヒューリスティクスを使用します。

これらの論文は技術を記述しています；KnossosはおそらくUUAAではPorcupine
最初の論文に基づいており、Porcupineは2番目の論文からのアイデアを
追加しています：

    http://www.cs.ox.ac.uk/people/gavin.lowe/LinearizabiltyTesting/paper.pdf
    https://arxiv.org/pdf/1504.00204.pdf

----------

Q: サービスは線形化可能性チェッカーを使用して線形化可能性を実装しますか？

A: いいえ；チェッカーはテストの一部としてのみ使用されます。

----------

Q: では、サービスはどのように線形化可能性を実装するのですか？

A: サービスが単一サーバーとして実装され、レプリケーションやキャッシュや
内部並列性がない場合、サービスがクライアントリクエストを到着順に
一度に一つずつ実行するだけでほぼ十分です。主な複雑さは、ネットワークが
メッセージを失ったと考えてリクエストを再送信するクライアントから
生じます：副作用のあるリクエストに対して、サービスは任意の
クライアントリクエストを一度だけ実行するよう注意しなければなりません。
サービスがレプリケーションやキャッシュを含む場合、より複雑な
設計が必要です。

----------

Q: PorcupineまたはUZ似たようなテストフレームワークでテストされた
実世界システムの例はありますか？

A: そのようなテストは一般的です -- 例えば、
https://jepsen.io/analysesを見てください；Jepsenは多くのストレージ
システムの正しさ（および適切な場合は線形化可能性）をテストした組織です。

Porcupine特に、ここに例があります：

  https://www.vldb.org/pvldb/vol15/p2201-zare.pdf

----------

Q: 他の一貫性モデルにはどのようなものがありますか？

A: 以下を探してください：

    結果的一貫性
    因果的一貫性
    フォーク一貫性
    直列化可能性
    順次一貫性
    タイムライン一貫性

そして、データベース、CPUメモリ/キャッシュシステム、ファイルシステムの
世界から他にもあります。

一般的に、異なるモデルは、アプリケーションプログラマーにとって
どれほど直感的か、およびそれらでどれほどのパフォーマンスを得られるかが
異なります。例えば、結果的一貫性は多くの異常な結果を許可しますが
（例：書き込みが完了したとしても、その後の読み取りがそれを見ない
可能性がある）、分散/レプリケーション設定では線形化可能性よりも
高いパフォーマンスで実装できます。

----------

Q: なぜ線形化可能性は強い一貫性モデルと呼ばれるのですか？

A: アプリケーションプログラマーを驚かせる可能性のある多くの状況を
禁止するという意味で強いのです。

例えば、私がput(x, 22)を呼び出し、私のputが完了し、他の誰もxを
書き込まず、その後あなたがget(x)を呼び出す場合、線形化可能性は
あなたが22以外の値を見ないことを保証します。つまり、読み取りは
新鮮なデータを見ます。

別の例として、誰もxを書き込んでおらず、私がget(x)を呼び出し、
あなたがget(x)を呼び出す場合、我々は異なる値を見ることはありません。

これらの特性は、我々が見る他の一貫性モデル、例えば結果的一貫性や
因果的一貫性では真実ではありません。これらの後者のモデルは
しばしば「弱い」と呼ばれます。

----------

Q: 分散システムが正しいことを保証するために、実際には人々は
何をしているのですか？

A: 徹底的なテストが一般的な計画です。

形式的手法の使用も一般的です；いくつかの例をここで見てください：

https://arxiv.org/pdf/2210.13661.pdf

https://assets.amazon.science/67/f9/92733d574c11ba1a11bd08bfb8ae/how-amazon-web-services-uses-formal-methods.pdf

https://dl.acm.org/doi/abs/10.1145/3477132.3483540

https://www.ccs.neu.edu/~stavros/papers/2022-cpp-published.pdf

https://www.cs.purdue.edu/homes/pfonseca/papers/eurosys2017-dsbugs.pdf

https://www.andrew.cmu.edu/user/bparno/papers/ironfleet.pdf

----------

Q: なぜ線形化可能性が結果的一貫性などの他のものではなく
一貫性モデルとして使用されるのですか？

A: 人々はしばしば、結果的一貫性や因果的一貫性など、線形化可能性より
弱い一貫性を提供するストレージシステムを構築します。

線形化可能性はアプリケーション作成者にとって良い特性があります：

  * 読み取りは常に新鮮なデータを観測します。
  * 並行書き込みがない場合、すべての読み取り者が同じデータを見ます。
  * ほとんどの線形化可能システムでは、テストアンドセットのような
    ミニトランザクションを追加できます（ほとんどの線形化可能設計は
    各データ項目の操作を一度に一つずつ実行することになるため）。

結果的一貫性や因果的一貫性のような弱いスキームは、すべてのデータの
コピーをすぐに更新する必要がないため、より高いパフォーマンスを
許可できます。この高いパフォーマンスがしばしば決定要因です。
一部のアプリケーションでは、弱い一貫性は問題を引き起こしません。
例えば、画像や動画など、決して更新されないデータ項目を格納する場合です。

しかし、弱い一貫性はアプリケーション作成者にいくつかの複雑さを
導入します：

  * 読み取りは期限切れ（古い）データを観測する可能性があります。
  * 読み取りは書き込みを順序通りでなく観測する可能性があります。
  * 書き込んでから読み取る場合、自分の書き込みを見ずに、
    代わりに古いデータを見る可能性があります。
  * 同じ項目への並行更新は一度に一つずつ実行されないため、
    テストアンドセットやアトミックインクリメントのような
    ミニトランザクションを実装するのが困難です。

----------

Q: 線形化可能性の小さなオレンジ線をどこに置くかをどう決めるのですか -
操作の線形化ポイント？図では、リクエストの本体内の
どこかにランダムに描かれているように見えます。

A: アイデアは、実行が線形化可能であることを示すために、あなた（人間）が
小さなオレンジ線（線形化ポイント）を置く場所を見つける必要があるという
ことです。つまり、履歴が線形化可能であることを示すために、
これらの要件に適合する線形化ポイントの割り当て（したがって操作の順序）を
見つける必要があります：

  * すべての関数呼び出しは、その呼び出しと応答の間の
    ある瞬間に線形化ポイントを持ちます。

  * すべての関数は、順次定義で指定されたように動作し、
    線形化ポイントで瞬時に発生するように見えます。

そのため、線形化ポイントのいくつかの配置は、リクエストの時間範囲外に
あるため無効です；他のものは順次定義に違反するため無効です
（キー/値ストアの場合、違反は読み取りが最も最近に書き込まれた値を
観測しないことを意味し、「最近」は線形化ポイントを指します）。

複雑な履歴の場合、履歴が線形化可能であることを示す線形化ポイントの
割り当てを見つけるために、多くの線形化ポイントの割り当てを
試す必要があるかもしれません。それらすべてを試して、どれも
機能しない場合、履歴は線形化可能ではありません。

----------

Q: 2つのコマンドが同時に実行されている場合、一方のコマンドが
常に最初に実行される（つまり、常により早い線形化ポイントを持つ）
ような特定の動作を強制することができる場合はありますか？

A: 線形化可能ストレージサービス（例：GFS、またはあなたのLab 4）では、
複数のクライアントからのリクエストが並行である場合、サービスは
それらを実行する順序を自由に選択できます。実際には、ほとんどの
サービスは、リクエストがネットワークに到着する順序でリクエストを
実行します。実際の実装では、通常、線形化ポイントの明示的な概念は
含まれません。

----------

Q: より強い他のタイプの一貫性チェックを実行できますか？
どういうわけか、線形化可能性は直感的に非常に*役立つ*と感じません。
2つのコマンドを同じ時間に実行しても、異なるデータを読み取る
可能性があるためです。

A: 確かに、線形化可能性はロックを使用せずにプログラムでスレッドを
使用することを彷彿とさせます。この方法で正しくプログラムすることは
可能ですが、注意が必要です。

より強い一貫性の概念の例は、多くのデータベースにある
トランザクションで、使用されるデータを効果的にロックします。
複数のデータ項目を読み書きするプログラムの場合、トランザクションは
線形化可能性よりもプログラミングを簡単にします。「直列化可能性」は
トランザクションを提供する一貫性モデルの一つの名前です。

しかし、トランザクションシステムは、線形化可能システムよりも
大幅に複雑で、遅く、耐障害性を作るのが困難です。

----------

Q: 現実的なシステムの検証が「巨大な努力」を必要とするのは何ですか？

A: 検証はプログラムが正しいこと、つまり何らかの仕様に適合することが
保証されていることを証明することを意味します。複雑なプログラムに
ついて重要な定理を証明することは困難であることがわかります --
通常のプログラミングよりもはるかに困難です。

このコースのラボを試すことで、これを感じることができます：

  https://6826.csail.mit.edu/2020/

----------

Q: 割り当てられた読み物から、分散システムのほとんどは形式的に
正しいことが証明されていません。では、チームは製品を顧客に
出荷するのに十分に徹底的にテストしたと決めるのはどうするのですか？

A: 会社がお金を使い果たして破産する前に、製品の出荷を開始し、
収益を得ることは良いアイデアです。人々はその時点まで可能な限り
テストし、通常、製品が正しく動作しない可能性があることを理解して、
いくつかの初期顧客に製品を使用してもらう（そしてバグを明らかにする
助けをしてもらう）よう説得しようとします。製品が多くの顧客を
満足させるのに十分に機能的で、既知の主要なバグがない場合、
出荷の準備ができているかもしれません。

これとは独立して、賢い顧客は依存するソフトウェアもテストします。
真剣な組織は、どのソフトウェアもバグフリーであることを期待しません。

----------

Q: クライアントがコマンドを送信した時刻を線形化ポイントとして
使用しないのはなぜですか？つまり、システムがクライアントが
送信した順序で操作を実行するのはなぜですか？

A: その動作を保証するシステムを構築するのは困難です -- 開始時刻は
クライアントコードがリクエストを発行した時刻ですが、ネットワーク
遅延のためサービスがリクエストを受信するのははるかに後かもしれません。
つまり、リクエストは開始時刻の順序とはかなり異なる順序で
サービスに到着する可能性があります。サービスは原則として、
より早い発行時刻を持つリクエストが後で到着する場合に備えて、
到着するすべてのリクエストの実行を遅らせることができますが、
ネットワークは無制限の遅延を課す可能性があるため、どのくらい
待つべきかを知るのは困難です。そして、すべてのリクエストの
遅延を、おそらく大幅に増加させるでしょう。とはいえ、後で見る
Spannerは関連する技術を使用します。

線形化可能性のような正しさ仕様は、効率的に実装するのに十分に緩く、
しかしアプリケーションプログラムに有用な保証を提供するのに十分に
厳格である間の微妙なバランスを歩く必要があります。「呼び出し順で
操作を実行するように見える」は効率的に実装するには厳しすぎますが、
線形化可能性の「呼び出しと応答の間のどこかで実行するように見える」は
実装可能ですが、アプリケーションプログラマーにとって
それほど直接的ではありません。

----------

Q: 並行put()もある場合、並行get()が異なる値を見る可能性があることは
問題ですか？

A: ストレージシステムのコンテキストでしばしば問題ではありません。
例えば、話している値が私のプロフィール写真で、2人の異なる人が
私が写真を更新している同じ時間にそれを見ようとする場合、
彼らが異なる写真（古いものまたは新しいもの）を見ることは
合理的です。

----------

Q: 線形化可能性がより弱いモデルよりもプログラムしやすい
アプリケーション状況にはどのようなものがありますか？

A: アプリケーションの一部が値を計算し、それをストレージシステムに
書き込み、次に計算された値が準備できていることを示すフラグを
ストレージシステムに設定するとします：

  v = compute...
  put("value", v)
  put("done", true)

別のコンピューターで、プログラムが値が利用可能かどうかを確認するために
"done"をチェックし、利用可能な場合はそれを使用します：

  if get("done") == true:
    v = get("value")
    print v

put()とget()を実装するストレージシステムが線形化可能である場合、
上記のプログラムは期待通りに動作します。

多くの弱い一貫性モデルでは、上記のプログラムは期待するように
動作しません。例えば、「結果的一貫性」を提供するストレージシステムは
2つのputを再順序付けする可能性があり（"done"が真であっても
"value"が利用できない）、またはget()のいずれかについて
古い（古い）値を返す可能性があります。

----------

Q: 実世界の線形化可能ストレージシステムの例にはどのようなものが
ありますか？そして、より弱い一貫性保証を持つストレージシステムは？

A: GoogleのSpannerとAmazonのS3は線形化可能性を提供する
ストレージシステムです。

GoogleのGFS、AmazonのDynamo、Cassandraはより弱い一貫性を提供します；
それらはおそらく結果的に一貫性があるものとして最もよく分類されます。