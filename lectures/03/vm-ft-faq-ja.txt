VMware FT FAQ

Q: なぜこの論文を読むのか、そこから何を学ぶべきか？

A: この論文を読む主な理由は、耐障害性を達成するためのレプリケート
されたステートマシンのアプローチとその課題（例：決定論、一貫性、スプ
リットブレイン）の明確なケーススタディを提供しており、これは今学期中
に（ラボを含めて）何度も見ることになるからです。もう一つの理由は、
この論文が驚くべきものだからです：このような低レベル（マシン命令）で
のレプリケーションはコストがかかりすぎると思うかもしれませんが、著者
たちはそれを実現し、ネットワークサーバーをFT上で実行することで耐障害
性を持たせることができるという良い利点があります（サーバーがあまり通
信集約的でない限り）。

----------

Q: クラウドプロバイダーは耐障害性にVM FTを使用していますか？

A: クラウドプロバイダーはステートマシンレプリケーションを使用します
が、後の論文で見るように、より良いパフォーマンスを達成するために、マ
シン命令レベルではなくアプリケーションレベルで実装されることが多いで
す。

----------

Q: 導入部では、物理サーバーよりもVMで決定論的実行を確保する方が困難
であると述べています。なぜそうなのでしょうか？

A: VMでの決定論の確保が簡単なのは、ハイパーバイザーが、例えば割り込
み配信の正確なタイミングなど、プライマリとバックアップの実行間で異な
る可能性があるハードウェアの多くの側面をエミュレートし制御するからで
す。

----------

Q: ハイパーバイザーとは何ですか？

A: ハイパーバイザーは仮想マシンシステムの一部であり、仮想マシンモニ
ター（VMM）と同じです。ハイパーバイザーはコンピューターをエミュレー
トし、ゲストオペレーティングシステム（およびアプリケーション）がエミ
ュレートされたコンピューター内で実行されます。ゲストが実行されるエミ
ュレーションは、しばしば仮想マシンと呼ばれます。この論文では、プライ
マリとバックアップは仮想マシン内で実行されるゲストであり、FTは各仮想
マシンを実装するハイパーバイザーの一部です。

----------

Q: GFSとVMware FTの両方が耐障害性を提供します。どちらが良いかをどう
考えるべきでしょうか？

A: FTは計算をレプリケートします；既存のネットワークサーバーに透過的
に耐障害性を追加するために使用できます。FTはかなり厳密な一貫性を提供
し、サーバーとクライアントに対して透明です。例えば、既存のメールサー
バーを耐障害性にするためにFTを使用することができます。対照的に、GFS
はストレージのみに耐障害性を提供します。GFSは特定のシンプルなサービ
ス（ストレージ）に特化しているため、そのレプリケーションはFTよりも効
率的です。例えば、GFSはすべてのレプリカで正確に同じ命令で割り込みを
発生させる必要がありません。GFSは通常、完全な耐障害性サービスを実装
するためのより大きなシステムの一部分に過ぎません。例えば、VMware FT
自体は、プライマリとバックアップによって共有される耐障害性ストレージ
サービス（図1の共有ディスク）に依存しており、それを実装するためにGFS
のようなものを使用できます（ただし詳細レベルでは、GFSはFTにとって適
切ではないでしょう）。

----------

Q: セクション3.4のバウンスバッファーはどのように競合状態を回避するの
に役立ちますか？

A: 問題は、ネットワークパケットまたは要求されたディスクブロックがプ
ライマリに到着し、プライマリのメモリにコピーされる必要があるときに発
生します。FTなしでは、関連するハードウェアがソフトウェアの実行中にデ
ータをメモリにコピーします。ゲスト命令はDMA中にそのメモリを読み取る
ことができます；正確なタイミングに応じて、ゲストはDMA'd データを見る
か見ないかもしれません（これが競合です）。プライマリとバックアップの
両方がこれを行った場合、わずかなタイミングの違いにより、一方はDMAの
直後に読み取り、もう一方は直前に読み取る可能性があるため、悪いことに
なります。その場合、それらは分岐します。

FTは、プライマリまたはバックアップが実行中にゲストメモリにコピーしな
いことで、この問題を回避します。FTは最初に、プライマリがアクセスでき
ないプライベートな「バウンスバッファー」にネットワークパケットまたは
ディスクブロックをコピーします。この最初のコピーが完了すると、FTハイ
パーバイザーはプライマリが実行していないようにプライマリを割り込みま
す。FTは（他の割り込みと同様に）プライマリを割り込んだポイントを記録
します。その後、FTはバウンスバッファーをプライマリのメモリにコピーし、
その後プライマリの実行継続を許可します。FTはログチャネルでバックアッ
プにデータを送信します。バックアップのFTは、プライマリが割り込まれた
のと同じ命令でバックアップを割り込み、バックアップが実行中にデータを
バックアップのメモリにコピーし、その後バックアップを再開します。

効果は、ネットワークパケットまたはディスクブロックがプライマリとバッ
クアップでまったく同じ時間に現れることであり、いつメモリを読み取って
も、両方が同じデータを見ることです。

----------

Q: 「共有ストレージ上のアトミックtest-and-set操作」とは何ですか？

A: システムは、プライマリとバックアップの両方によって共有されるネッ
トワークディスクサーバー（図1の「共有ディスク」）を使用します。その
ネットワークディスクサーバーには「test-and-setサービス」があります。
test-and-setサービスは、最初にfalseに設定されているフラグを維持しま
す。プライマリまたはバックアップが他方のサーバーが死んでいると思い、
したがって自分が一人で引き継ぐべきだと思う場合、最初にディスクサーバ
ーにtest-and-set操作を送信します。サーバーは大まかに次のコードを実行
します：

  test-and-set() {
    acquire_lock()
    if flag == true:
      release_lock()
      return false
    else:
      flag = true
      release_lock()
      return true

プライマリ（またはバックアップ）は、test-and-setがtrueを返す場合にの
み引き継ぎ（「ライブになる」）ます。

より高レベルな視点は、プライマリとバックアップが互いとのネットワーク
接続を失った場合、そのうちの1つだけがライブになることを望むというこ
とです。危険は、両方が稼働していてネットワークが故障した場合、両方が
ライブになってスプリットブレインを発生させる可能性があることです。プ
ライマリまたはバックアップの1つだけがディスクサーバーと通信できる場
合、そのサーバーだけがライブになります。しかし、両方がディスクサーバ
ーと通信できる場合はどうでしょうか？その場合、ネットワークディスクサ
ーバーはタイブレーカーとして機能します；test-and-setは最初の呼び出し
にのみtrueを返します。

----------

Q: 出力ルールに従うことでどの程度のパフォーマンスが失われますか？

A: 表2がいくつかの洞察を提供します。出力ルールに従うことで、送信レー
トは減少しますが、大幅にではありません。

----------

Q: アプリケーションが乱数生成器を呼び出した場合はどうなりますか？そ
れはプライマリとバックアップで異なる結果をもたらし、実行を分岐させま
せんか？

A: FTは、プライマリとバックアップが乱数生成器から同じ数を取得するよ
うに配置します。ランダム性のすべてのソースはハイパーバイザーによって
制御されます。例えば、アプリケーションは現在時刻、ハードウェアサイク
ルカウンター、または正確な割り込み時間をランダム性のソースとして使用
する場合があります。これら3つすべての場合において、ハイパーバイザー
はプライマリとバックアップの両方で関連する命令を傍受し、同じ値を生成
することを保証します。

----------

Q: 作成者たちは、すべての可能な非決定論の形式を捕捉したことをどのよ
うに確信していましたか？

A: 私の推測は次の通りです。著者たちは、多くの人がVMハイパーバイザー、
マイクロプロセッサー、ゲストOSの内部をよく理解し、多くの落とし穴を知
っている会社で働いています。VM-FT専用に、著者たちは以前のプロジェクト
（決定論的リプレイ）からのログとリプレイサポートを活用しており、それ
はすでに非決定論のソースを扱っていたはずです。決定論的リプレイの設計
者たちが広範囲のテストを行い、VM-FTの著者たちが使用する非決定論のソ
ースに関する経験を得ていたと仮定します。

----------

Q: プライマリが外部世界に出力を送信した直後に故障した場合はどうなり
ますか？

A: バックアップは引き継ぎ後に出力を繰り返す可能性が高く、そのため2回
生成されます。この重複は、ネットワークとディスクI/Oにとって問題では
ありません。出力がネットワークパケットの場合、受信クライアントのTCP
ソフトウェアが自動的に重複を破棄します。出力イベントがディスクI/Oの
場合、ディスクI/Oは冪等です（両方が同じデータを同じ場所に書き込み、
間にI/Oがありません）。

----------

Q: セクション3.4では、故障が発生したときにプライマリで未処理のディス
クI/Oについて話しており、「代わりに、バックアップVMのgo-liveプロセス
中に保留中のI/Oを再発行します」と述べています。保留中のI/Oはどこに配
置/保存されており、再発行はどこまで戻る必要がありますか？

A: 論文は、I/Oが開始されたことを示すログエントリはあるが、完了を示す
エントリがないディスクI/Oについて話しています。これらは、バックアッ
プで再開されなければならないI/O操作です。I/Oが完了すると、I/Oデバイ
スがI/O完了割り込みを生成します。そのため、I/O完了割り込みがログに欠
けている場合、バックアップはI/Oを再開します。ログにI/O完了割り込みが
ある場合、I/Oを再開する必要はありません。

----------

Q: バックアップFTは、バックアップ命令ストリームの特定のポイント（つ
まり、プライマリで割り込みが元々発生したのと同じ命令）で割り込みを配
信することができますか？

A: 多くのCPUは、FT VMMがCPUに命令数を伝えることができる機能（「パフ
ォーマンスカウンター」）をサポートしており、CPUはその命令数の後にFT 
VMMに割り込みます。

----------

Q: このシステムはどの程度セキュアですか？

A: 著者たちは、プライマリとバックアップのハイパーバイザーがプロトコ
ルに従い、悪意がない（例えば、攻撃者がハイパーバイザーを危険にさらし
ていない）と仮定しています。システムは危険にさらされたハイパーバイザ
ーを処理できません。一方、ハイパーバイザーは、悪意のあるまたはバグの
あるゲストオペレーティングシステムやアプリケーションから自分自身を守
ることができるでしょう；FTは忠実に悪意やバグをレプリケートします。

----------

Q: フェイルストップ障害のみに対処することは合理的ですか？他の種類の
障害は何ですか？

A: それは合理的です。多くの実世界の障害は本質的にフェイルストップだ
からです。例えば、多くのネットワークや電力障害。これよりも良くするに
は、正しく動作しているように見えるが実際には間違った結果を計算するコ
ンピューターに対処する必要があります；最悪の場合、おそらく障害は悪意
のある攻撃者の結果です。このより大きなクラスの非フェイルストップ障害
は、しばしば「ビザンチン」と呼ばれます。コースの最後に触れるビザンチ
ン障害に対処する方法がありますが、6.824のほとんどはフェイルストップ
障害についてです。

----------

Q: 低いオーバーヘッド（表1）があり、既存のソフトウェアの下に滑り込ま
せるのが簡単である場合、FTは多く使用されていますか？

A: わかりませんが、著者たちが期待したほど使われていないという感じが
します。オープンソースソフトウェア上に構築された大きなウェブサイトの
世界では、人々は主にアプリケーション固有のレプリケーションスキームを
使用します。心に留めておくべきことの1つは、FTはユニプロセッサVMゲス
トのみをサポートするため、サーバーはCPU並列性をサポートできないこと
です。もう1つのポイントは、表1の「ログ帯域幅」列が、論文のベンチマー
クがあまりI/O集約的ではないことを示唆していることです。単一のディス
クまたはネットワークインターフェースは、その列の値よりもはるかに多く
のトラフィックを生成する可能性があるからです。最後の考えは、サービス
が重要な状態を別の耐障害性共有ディスクに保存していることを考えると、
FTスタイルのホットバックアップに対する根本的な必要性はあまりありませ
ん；サーバーが故障した場合、原則として新しいサーバーを他のマシンで起
動し、共有ディスクから状態をロードできます。データベースは既にクラッ
シュ回復のためにこれを行う方法を知っています。

----------

Q: 論文ではFTがマルチプロセッサゲストに対処しないと述べています。な
ぜですか？

A: 一般的に、複数のプロセッサで実行されるソフトウェアの結果は、プロ
セッサ上の命令ストリームがどのようにインターリーブされたかに正確に依
存します。FTがバックアップをプライマリと同期させることを保証するため
には、両方のコンピューターでインターリーブを同じにする必要があります。
これは困難であることがわかります：プライマリでのインターリーブが何で
あるかを簡単に見つけることができず、どちらのマシンでもそれを簡単に制
御することができません。

より最近のVMware製品はマルチプロセッサゲストをレプリケートしており、
おそらく異なる技術（操作ではなくメモリスナップショットをレプリケート？
）を使用しています。

----------

Q: サーバーS1がプライマリとして動作し、S2がバックアップとしている場
合を仮定します。それらの間のネットワークリンクが動作を停止します。S2
はもはやS1と通信できないことを見て「ライブになり」、test-and-setロッ
クを正常に取得した後、唯一のサーバーとして引き継ぎます。S1はS2がライ
ブになったことを認識しますか？それともS1は動作を続け、「スプリットブ
レイン」を引き起こす可能性がありますか？

A: S1は実際に何が起こっているかを認識しない可能性があり、クライアン
トはしばらくの間S1にリクエストを送信し続ける可能性があります。しか
し、S1が次に出力を生成したい場合（クライアントまたは共有ディスクに）、
出力ルールはS1がすべての未処理のログエントリをS2が確認するのを待つこ
とを要求します。S2は確認しません；S1とS2が通信できても、S2はもはやバ
ックアップではないため、S1のログエントリに応答すべきではないことを知
っています。そのため、S1はS2がライブになることを決定した後、出力を生
成することができません。そのため、S1がまだプライマリだと思っていると
いう事実は、実際にはスプリットブレインを引き起こしません。

このパターンは、プライマリが自分がまだプライマリであることをバックア
ップに確認してもらえない場合に停止を強制されるもので、スプリットブレ
インを防ぐストーリーの一部として多くのレプリケーションシステムで発生
します。