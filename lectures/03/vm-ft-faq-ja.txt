VMware FT FAQ

Q: なぜこの論文を読むのか、そこから何を学ぶべきか？

A: この論文を読む主な理由は、耐障害性を達成するためのレプリケートされたステートマシンのアプローチとその課題（例：決定論、一貫性、スプリットブレイン）の明確なケーススタディを提供しており、これは今学期中に（ラボを含めて）何度も見ることになるからです。もう一つの理由は、この論文が驚くべきものだからです：このような低レベル（マシン命令）でのレプリケーションはコストがかかりすぎると思うかもしれませんが、著者たちはそれを実現し、ネットワークサーバーをFT上で実行することで耐障害性を持たせることができるという良い利点があります（サーバーがあまり通信集約的でない限り）。

Q: クラウドプロバイダーは耐障害性にVM FTを使用していますか？

A: クラウドプロバイダーはステートマシンレプリケーションを使用しますが、後の論文で見るように、より良いパフォーマンスを達成するために、マシン命令レベルではなくアプリケーションレベルで実装されることが多いです。

Q: 導入部では、物理サーバーよりもVMで決定論的実行を確保する方が困難であると述べています。なぜそうなのでしょうか？

A: VMでの決定論の確保が簡単なのは、ハイパーバイザーが、例えば割り込み配信の正確なタイミングなど、プライマリとバックアップの実行間で異なる可能性があるハードウェアの多くの側面をエミュレートし制御するからです。

Q: ハイパーバイザーとは何ですか？

A: ハイパーバイザーは仮想マシンシステムの一部であり、仮想マシンモニター（VMM）と同じです。ハイパーバイザーはコンピューターをエミュレートし、ゲストオペレーティングシステム（およびアプリケーション）がエミュレートされたコンピューター内で実行されます。ゲストが実行されるエミュレーションは、しばしば仮想マシンと呼ばれます。この論文では、プライマリとバックアップは仮想マシン内で実行されるゲストであり、FTは各仮想マシンを実装するハイパーバイザーの一部です。

Q: GFSとVMware FTの両方が耐障害性を提供します。どちらが良いかをどう考えるべきでしょうか？

A: FTは計算をレプリケートします；既存のネットワークサーバーに透過的に耐障害性を追加するために使用できます。FTはかなり厳密な一貫性を提供し、サーバーとクライアントに対して透明です。例えば、既存のメールサーバーを耐障害性にするためにFTを使用することができます。対照的に、GFSはストレージのみに耐障害性を提供します。GFSは特定のシンプルなサービス（ストレージ）に特化しているため、そのレプリケーションはFTよりも効率的です。例えば、GFSはすべてのレプリカで正確に同じ命令で割り込みを発生させる必要がありません。GFSは通常、完全な耐障害性サービスを実装するためのより大きなシステムの一部分に過ぎません。例えば、VMware FT自体は、プライマリとバックアップによって共有される耐障害性ストレージサービス（図1の共有ディスク）に依存しており、それを実装するためにGFSのようなものを使用できます（ただし詳細レベルでは、GFSはFTにとって適切ではないでしょう）。

Q: セクション3.4のバウンスバッファーはどのように競合状態を回避するのに役立ちますか？

A: 問題は、ネットワークパケットまたは要求されたディスクブロックがプライマリに到着し、プライマリのメモリにコピーされる必要があるときに発生します。FTなしでは、関連するハードウェアがソフトウェアの実行中にデータをメモリにコピーします。ゲスト命令はDMA中にそのメモリを読み取ることができます；正確なタイミングに応じて、ゲストはDMA'd データを見るか見ないかもしれません（これが競合です）。プライマリとバックアップの両方がこれを行った場合、わずかなタイミングの違いにより、一方はDMAの直後に読み取り、もう一方は直前に読み取る可能性があるため、悪いことになります。その場合、それらは分岐します。

FTは、プライマリまたはバックアップが実行中にゲストメモリにコピーしないことで、この問題を回避します。FTは最初に、プライマリがアクセスできないプライベートな「バウンスバッファー」にネットワークパケットまたはディスクブロックをコピーします。この最初のコピーが完了すると、FTハイパーバイザーはプライマリが実行していないようにプライマリを割り込みます。FTは（他の割り込みと同様に）プライマリを割り込んだポイントを記録します。その後、FTはバウンスバッファーをプライマリのメモリにコピーし、その後プライマリの実行継続を許可します。FTはログチャネルでバックアップにデータを送信します。バックアップのFTは、プライマリが割り込まれたのと同じ命令でバックアップを割り込み、バックアップが実行中にデータをバックアップのメモリにコピーし、その後バックアップを再開します。

効果は、ネットワークパケットまたはディスクブロックがプライマリとバックアップでまったく同じ時間に現れることであり、いつメモリを読み取っても、両方が同じデータを見ることです。

Q: 「共有ストレージ上のアトミックtest-and-set操作」とは何ですか？

A: システムは、プライマリとバックアップの両方によって共有されるネットワークディスクサーバー（図1の「共有ディスク」）を使用します。そのネットワークディスクサーバーには「test-and-setサービス」があります。test-and-setサービスは、最初にfalseに設定されているフラグを維持します。プライマリまたはバックアップが他方のサーバーが死んでいると思い、したがって自分が一人で引き継ぐべきだと思う場合、最初にディスクサーバーにtest-and-set操作を送信します。サーバーは大まかに次のコードを実行します：

  test-and-set() {
    acquire_lock()
    if flag == true:
      release_lock()
      return false
    else:
      flag = true
      release_lock()
      return true

プライマリ（またはバックアップ）は、test-and-setがtrueを返す場合にのみ引き継ぎ（「ライブになる」）ます。

より高レベルな視点は、プライマリとバックアップが互いとのネットワーク接続を失った場合、そのうちの1つだけがライブになることを望むということです。危険は、両方が稼働していてネットワークが故障した場合、両方がライブになってスプリットブレインを発生させる可能性があることです。プライマリまたはバックアップの1つだけがディスクサーバーと通信できる場合、そのサーバーだけがライブになります。しかし、両方がディスクサーバーと通信できる場合はどうでしょうか？その場合、ネットワークディスクサーバーはタイブレーカーとして機能します；test-and-setは最初の呼び出しにのみtrueを返します。

Q: 出力ルールに従うことでどの程度のパフォーマンスが失われますか？

A: 表2がいくつかの洞察を提供します。出力ルールに従うことで、送信レートは減少しますが、大幅にではありません。

Q: アプリケーションが乱数生成器を呼び出した場合はどうなりますか？それはプライマリとバックアップで異なる結果をもたらし、実行を分岐させませんか？

A: FTは、プライマリとバックアップが乱数生成器から同じ数を取得するように配置します。ランダム性のすべてのソースはハイパーバイザーによって制御されます。例えば、アプリケーションは現在時刻、ハードウェアサイクルカウンター、または正確な割り込み時間をランダム性のソースとして使用する場合があります。これら3つすべての場合において、ハイパーバイザーはプライマリとバックアップの両方で関連する命令を傍受し、同じ値を生成することを保証します。

Q: 作成者たちは、すべての可能な非決定論の形式を捕捉したことをどのように確信していましたか？

A: 私の推測は次の通りです。著者たちは、多くの人がVMハイパーバイザー、マイクロプロセッサー、ゲストOSの内部をよく理解し、多くの落とし穴を知っている会社で働いています。VM-FT専用に、著者たちは以前のプロジェクト（決定論的リプレイ）からのログとリプレイサポートを活用しており、それはすでに非決定論のソースを扱っていたはずです。決定論的リプレイの設計者たちが広範囲のテストを行い、VM-FTの著者たちが使用する非決定論のソースに関する経験を得ていたと仮定します。

Q: プライマリが外部世界に出力を送信した直後に故障した場合はどうなりますか？

A: バックアップは引き継ぎ後に出力を繰り返す可能性が高く、そのため2回生成されます。この重複は、ネットワークとディスクI/Oにとって問題ではありません。出力がネットワークパケットの場合、受信クライアントのTCPソフトウェアが自動的に重複を破棄します。出力イベントがディスクI/Oの場合、ディスクI/Oは冪等です（両方が同じデータを同じ場所に書き込み、間にI/Oがありません）。

Q: セクション3.4では、故障が発生したときにプライマリで未処理のディスクI/Oについて話しており、「代わりに、バックアップVMのgo-liveプロセス中に保留中のI/Oを再発行します」と述べています。保留中のI/Oはどこに配置/保存されており、再発行はどこまで戻る必要がありますか？

A: 論文は、I/Oが開始されたことを示すログエントリはあるが、完了を示すエントリがないディスクI/Oについて話しています。これらは、バックアップで再開されなければならないI/O操作です。I/Oが完了すると、I/OデバイスがI/O完了割り込みを生成します。そのため、I/O完了割り込みがログに欠けている場合、バックアップはI/Oを再開します。ログにI/O完了割り込みがある場合、I/Oを再開する必要はありません。

Q: バックアップFTは、バックアップ命令ストリームの特定のポイント（つまり、プライマリで割り込みが元々発生したのと同じ命令）で割り込みを配信することができますか？

A: 多くのCPUは、FT VMMがCPUに命令数を伝えることができる機能（「パフォーマンスカウンター」）をサポートしており、CPUはその命令数の後にFT VMMに割り込みます。

Q: このシステムはどの程度セキュアですか？

A: 著者たちは、プライマリとバックアップのハイパーバイザーがプロトコルに従い、悪意がない（例えば、攻撃者がハイパーバイザーを危険にさらしていない）と仮定しています。システムは危険にさらされたハイパーバイザーを処理できません。一方、ハイパーバイザーは、悪意のあるまたはバグのあるゲストオペレーティングシステムやアプリケーションから自分自身を守ることができるでしょう；FTは忠実に悪意やバグをレプリケートします。

Q: フェイルストップ障害のみに対処することは合理的ですか？他の種類の障害は何ですか？

A: それは合理的です。多くの実世界の障害は本質的にフェイルストップだからです。例えば、多くのネットワークや電力障害。これよりも良くするには、正しく動作しているように見えるが実際には間違った結果を計算するコンピューターに対処する必要があります；最悪の場合、おそらく障害は悪意のある攻撃者の結果です。このより大きなクラスの非フェイルストップ障害は、しばしば「ビザンチン」と呼ばれます。コースの最後に触れるビザンチン障害に対処する方法がありますが、6.824のほとんどはフェイルストップ障害についてです。

Q: 低いオーバーヘッド（表1）があり、既存のソフトウェアの下に滑り込ませるのが簡単である場合、FTは多く使用されていますか？

A: わかりませんが、著者たちが期待したほど使われていないという感じがします。オープンソースソフトウェア上に構築された大きなウェブサイトの世界では、人々は主にアプリケーション固有のレプリケーションスキームを使用します。心に留めておくべきことの1つは、FTはユニプロセッサVMゲストのみをサポートするため、サーバーはCPU並列性をサポートできないことです。もう1つのポイントは、表1の「ログ帯域幅」列が、論文のベンチマークがあまりI/O集約的ではないことを示唆していることです。単一のディスクまたはネットワークインターフェースは、その列の値よりもはるかに多くのトラフィックを生成する可能性があるからです。最後の考えは、サービスが重要な状態を別の耐障害性共有ディスクに保存していることを考えると、FTスタイルのホットバックアップに対する根本的な必要性はあまりありません；サーバーが故障した場合、原則として新しいサーバーを他のマシンで起動し、共有ディスクから状態をロードできます。データベースは既にクラッシュ回復のためにこれを行う方法を知っています。

Q: 論文ではFTがマルチプロセッサゲストに対処しないと述べています。なぜですか？

A: 一般的に、複数のプロセッサで実行されるソフトウェアの結果は、プロセッサ上の命令ストリームがどのようにインターリーブされたかに正確に依存します。FTがバックアップをプライマリと同期させることを保証するためには、両方のコンピューターでインターリーブを同じにする必要があります。これは困難であることがわかります：プライマリでのインターリーブが何であるかを簡単に見つけることができず、どちらのマシンでもそれを簡単に制御することができません。

より最近のVMware製品はマルチプロセッサゲストをレプリケートしており、おそらく異なる技術（操作ではなくメモリスナップショットをレプリケート？）を使用しています。

Q: サーバーS1がプライマリとして動作し、S2がバックアップとしている場合を仮定します。それらの間のネットワークリンクが動作を停止します。S2はもはやS1と通信できないことを見て「ライブになり」、test-and-setロックを正常に取得した後、唯一のサーバーとして引き継ぎます。S1はS2がライブになったことを認識しますか？それともS1は動作を続け、「スプリットブレイン」を引き起こす可能性がありますか？

A: S1は実際に何が起こっているかを認識しない可能性があり、クライアントはしばらくの間S1にリクエストを送信し続ける可能性があります。しかし、S1が次に出力を生成したい場合（クライアントまたは共有ディスクに）、出力ルールはS1がすべての未処理のログエントリをS2が確認するのを待つことを要求します。S2は確認しません；S1とS2が通信できても、S2はもはやバックアップではないため、S1のログエントリに応答すべきではないことを知っています。そのため、S1はS2がライブになることを決定した後、出力を生成することができません。そのため、S1がまだプライマリだと思っているという事実は、実際にはスプリットブレインを引き起こしません。

このパターンは、プライマリが自分がまだプライマリであることをバックアップに確認してもらえない場合に停止を強制されるもので、スプリットブレインを防ぐストーリーの一部として多くのレプリケーションシステムで発生します。