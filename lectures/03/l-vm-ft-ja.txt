6.5840 2025 講義3: プライマリ/バックアップレプリケーション

今日
  耐障害性のためのプライマリ/バックアップレプリケーション
  VMware FT (2010)のケーススタディ、このアイデアの極端なバージョン

なぜこの論文を読むのか？
  今学期で何度も出てくる多くの問題を浮き彫りにする
  クリーンなプライマリ/バックアップ設計
    ステートマシンレプリケーション
    出力ルール
    フェイルオーバー/プライマリ選択
  マシン命令レベルでこれができるのは印象的
    どんなアプリケーションでも取得してVM FTでレプリケートできる
    今学期後半のすべての設計はアプリケーション設計者による作業を含む

目標: 高可用性
  マシンが故障しても、サービスを提供する
    つまり、マシンが故障してもダウンタイムがない
  アプローチ: レプリケーション

レプリケーションはどのような種類の障害に対処できるか？
  レプリケーションは単一レプリカの「フェイルストップ」障害に有効
    ファンが動作を停止、CPUが過熱して自動シャットダウン
    誰かがレプリカの電源ケーブルやネットワークケーブルを踏む
    ソフトウェアがディスク容量不足に気づいて停止
  レプリケーションはバグやオペレーターエラーには役立たない場合がある
    多くの場合、フェイルストップではない
    相関がある可能性（つまり、ある入力がすべてのレプリカをクラッシュさせる）
  地震や都市全体の停電はどうか？
    レプリカが物理的に分離されている場合のみ

レプリケーションへの人気のあるアプローチ: レプリケートされたステートマシン
  クライアントがプライマリに操作を送信、
    プライマリが順序付けしてバックアップに送信
  すべてのレプリカがすべての操作を実行
    同じ開始状態、
      同じ操作、
      同じ順序、
      決定論的、
      なら同じ終了状態。
 （レプリケーションへの他のアプローチ: 状態転送）

VM-FTはレプリケートされたステートマシンを使用
  ラボでも同様
  他の割り当て論文でも同様

レプリカはいくつ？
  多くの場合、コストがかかるため少数を望む
  しかし修復中の障害を乗り切るのに十分
    多くのシステムは3-5個のレプリカで動作、後で見るように
  この論文は2個のレプリカのみで動作
    同時に1つの障害に対して回復力がある

大きな質問:
  状態と操作とは何か？
  プライマリはバックアップを待つ必要があるか？
  バックアップはどのように引き継ぎを決定するか？
  カットオーバー時に異常は見えるか？
  交換用バックアップを最新にしてレプリケーションを再開するには？

どのレベルでレプリカを同一にしたいか？
  アプリケーション状態、例えばデータベースのテーブル？
    GFSはこの方法で動作
    効率的；プライマリは高レベル操作のみをバックアップに送信
    アプリケーションは耐障害性を理解する必要がある
  マシンレベル、例えばレジスタとRAMの内容？
    既存のアプリケーションを変更なしでレプリケートできる可能性！
    マシンイベント（割り込み、ネットワークパケットなど）の転送が必要
    イベントストリームを送受信するための「マシン」変更が必要...

今日の論文（VMware FT）はマシンレベル状態をレプリケート
  透明: 既存のO/Sとサーバーソフトウェアを実行できる！
  クライアントには単一サーバーのように見える

概要
  [図: app, O/S, VM-FT underneath, disk server, network, clients]
  用語:
    hypervisor == monitor == VMM (virtual machine monitor)
    O/S+appは仮想マシン内で動作する「ゲスト」
  2台の物理マシン、プライマリとバックアップ

基本的なアイデア:
  プライマリとバックアップは最初に同一のメモリとレジスタで開始
    同一のソフトウェア（O/Sとapp）を含む
  ほとんどの命令はプライマリとバックアップで同一に実行される
    例えばADD命令
  そのため、ほとんどの場合、それらを同一に保つための作業は不要！

プライマリがバックアップに情報を送信する必要があるのはいつか？
  実行が分岐する可能性がある何かが起こったとき。
  命令実行の決定論的な結果ではないもの。

FTが排除しなければならない分岐の原因は？
  現在時刻の読み取りなど、状態の関数ではない命令。
  外部世界からの入力 -- ネットワークパケットとディスク読み取り。
    これらはDMA'd データと割り込みとして現れる。
  割り込みのタイミング。
  しかし、マルチコア競合は除く、ユニプロセッサのみなので。

なぜ分岐が災害になるのか？
  バックアップの状態がプライマリの状態と異なり、
    プライマリが失敗した場合、クライアントが不整合を見るから。
  例: 6.5840宿題提出サーバー
    ラボの午前0時締切を執行。
    午前0時にハードウェアタイマーが作動。
    *壊れた*FTで提出サーバーをレプリケートしよう。
    プライマリで、私の宿題パケット割り込みがタイマーが作動する*直前*に到着。
      プライマリは私に宿題の満点を教える。
    バックアップで、私の宿題は後に到着し、バックアップは遅刻と考える。
      プライマリとバックアップは今分岐した状態を持つ。
      今のところ、プライマリがすべてのリクエストに答えるため、誰も気づかない。
    その後プライマリが失敗、バックアップが引き継ぎ、コーススタッフは
      バックアップの状態を見て、私が遅刻したと表示！
  そのため: バックアップは同じイベントを、
    同じ順序で、
    命令ストリームの同じポイントで見る必要がある。

ログチャネル
  プライマリはすべてのイベントをネットワーク経由でバックアップに送信
    「ログチャネル」、ログエントリを運ぶ
    割り込み、着信ネットワークパケット、共有ディスクから読み取ったデータ
  FTはログエントリからバックアップの入力（割り込みなど）を提供
  FTはバックアップのネットワーク出力を抑制
  どちらかがネットワーク経由で他方との通信を停止した場合
    「ライブになり」単独でサービスを提供
    プライマリがライブになった場合、バックアップへのログエントリ送信を停止

各ログエントリ: 命令番号、タイプ、データ。

FTのタイマー割り込み処理
  目標: プライマリとバックアップは命令ストリームの
        まったく同じポイントで割り込みを見るべき
  プライマリ:
    FTがタイマー割り込みを処理
    FTがCPUから命令番号を読み取り
    FTがログチャネルで「命令番号Xでのタイマー割り込み」を送信
    FTが割り込みをプライマリに配信し、再開
    （FTソフトウェアに割り込みを向けるCPUサポートに依存）
  バックアップ:
    自身のタイマーハードウェアを無視
    FTがバックアップが命令番号Xに到達する*前に*ログエントリを見る
    FTがCPUに命令番号XでFTに制御を移すよう指示
    FTがバックアップゲストが見るタイマー割り込みを模倣
    （X番目の命令後にFTにジャンプするCPUサポートに依存）

FTのネットワークパケット到着（入力）処理
  プライマリ:
    FTがNICをFTのプライベート「バウンスバッファ」にパケットデータを書き込むよう設定
    ある時点でパケットが到着、NICがDMAを実行、その後割り込み
    FTが割り込みを取得、CPUから命令番号を読み取り
    FTがプライマリを一時停止
    FTがバウンスバッファをプライマリのメモリにコピー
    FTがプライマリでNIC割り込みをシミュレート
    FTがパケットデータと命令番号をバックアップに送信
  バックアップ:
    FTがログストリームからデータと命令番号を取得
    FTがCPUに命令番号Xで（FTに）割り込むよう指示
    FTがデータをゲストメモリにコピー、バックアップでNIC割り込みをシミュレート

なぜバウンスバッファか？
  データがプライマリとバックアップの実行の
    まったく同じポイントでメモリに現れることを望む。
  割り込み前にパケットメモリを読み取った場合、同じものを見るように。
  そうでなければ分岐する可能性がある。

FT VMMはローカルディスクインターフェースをエミュレート
  しかし実際のストレージはネットワークサーバー上 -- 「共有ディスク」
  すべてのファイル/ディレクトリは共有ストレージ内；ローカルディスクはなし
  プライマリのみが共有ディスクと通信
    プライマリは読み取ったブロックをバックアップに転送
    バックアップのFTはバックアップアプリの書き込みを無視、プライマリのデータから読み取りを提供
  共有ディスクは新しいバックアップの作成をはるかに高速にする
    プライマリのディスクをコピーする必要がない

バックアップは1つのログエントリだけ遅れる必要がある
  プライマリが命令番号Xで割り込みを受けるとしよう
  バックアップがすでにXを過ぎて実行していたら、手遅れ！
  そのためバックアップFTは少なくとも1つのログエントリが待機していない限り実行できない
    その後、そのログエントリの命令番号まで実行
    次のログエントリを待ってから再開

例: 非決定論的命令
  プライマリ/バックアップが同じ状態を持っていても、一部の命令は異なる結果をもたらす
  例えば現在時刻やプロセッサシリアル番号の読み取り
  プライマリ:
    FTがプライマリがそのような命令を実行した場合に割り込むようCPUを設定
    FTが命令を実行し結果を記録
    結果と命令番号をバックアップに送信
  バックアップ:
    FTがログエントリを読み取り、命令番号での割り込みを設定
    FTがプライマリが取得した値を提供、命令を実行しない

出力（ネットワークパケット送信、共有ディスク書き込み）はどうか？
  プライマリとバックアップの両方が出力の命令を実行
  プライマリのFTが実際に出力を実行
  バックアップのFTが出力を破棄

出力例: DBサーバー
  クライアントは「インクリメント」リクエストを送信できる
    DBは保存された値をインクリメント、新しい値で応答
  そのため:
    [図]
    サーバーの値が10で始まるとしよう
    ネットワークがプライマリのFTにクライアントリクエストを配信
    プライマリのFTがログチャネルでバックアップに送信
    FTがリクエストパケットをプライマリとバックアップに配信
    プライマリが実行、値を11に設定、「11」応答を送信、FTが実際に応答を送信
    バックアップが実行、値を11に設定、「11」応答を送信、FTが破棄
    クライアントは期待通り1つの「11」応答を受信

しかし待って:
  プライマリが応答を送信してからクラッシュしたとしよう
    そのためクライアントは「11」応答を受信
  そしてログチャネルがクライアントリクエストを含むログエントリを破棄
    プライマリは死んでいるため、再送信しない
  バックアップがライブになる
    しかしメモリに値「10」を持っている！
  今クライアントが別のインクリメントリクエストを送信
    「12」ではなく再び「11」を受信する
  おっと

解決策: 出力ルール（セクション2.2）
  プライマリが出力を送信する前（例えばクライアントや共有ディスクに）、
  すべての以前のログエントリのバックアップからの確認応答を待つ必要がある

再び、出力ルールを使って:
  [図]
  プライマリ:
    クライアント「インクリメント」リクエストを受信
    ログチャネルでクライアントリクエストを送信
    クライアントに「11」応答を送信しようとする
    最初にバックアップから以前のログエントリの確認応答を待つ
    その後クライアントに「11」応答を送信
  この順序のある時点でプライマリがクラッシュしたとしよう
  バックアップからの確認応答をプライマリが受信する前の場合
    多分バックアップはクライアントのリクエストを見ておらず、インクリメントしなかった
    しかしプライマリも応答していない
  バックアップからの確認応答をプライマリが受信した後の場合
    その後クライアントは「11」応答を見る可能性がある
    しかしバックアップはクライアントのリクエストを含むログエントリを受信することが保証される
    そのためバックアップは11にインクリメントする

出力ルールは大きな問題
  ほぼすべての強い一貫性レプリケーションシステムで何らかの形で発生
    プライマリが待つ必要があるため「同期レプリケーション」とよく呼ばれる
  パフォーマンスに対する深刻な制約
  アプリケーション固有の巧妙さの領域
    例えば読み取り専用操作に応答する前にプライマリが待つ必要がない可能性
  FTはアプリケーションレベルの知識を持たず、保守的でなければならない

Q: バックアップからの確認応答を受信した直後にプライマリがクラッシュしたが、
   プライマリが出力を送信する前だった場合はどうか？
   これは出力が生成されないことを意味するか？

A: バックアップは、クライアントに応答パケットを送信する命令の前または後に
   ライブになる。
   前の場合、応答パケットを送信する。
   後の場合、FTがパケットを破棄している。しかしバックアップの
   TCPはそれを送信したと思い、TCP ACKパケットを期待し、
   ACKを受信しなければ再送信する。

Q: しかしプライマリが出力を送信した*後*にクラッシュした場合はどうか？
   バックアップは出力を*2回目*に送信するか？

A: そうする可能性がある！
   TCPには問題ない、受信者は重複シーケンス番号を無視するため。
   共有ディスクへの書き込みには問題ない、
   バックアップは同じデータを同じブロック番号に書き込むため。

カットオーバー時の重複出力はレプリケーションシステムでかなり一般的
  クライアントは重複を無視するのに十分な状態を保持する必要がある
  または重複が無害になるよう設計される
  VM FTは重複検出を「無料で」取得、
    TCP状態はVM FTによってバックアップ上で重複される

Q: FTはネットワーク分断に対処するか -- スプリットブレインに苦しむ可能性があるか？
   例えばプライマリとバックアップの両方が他方がダウンしていると思う場合。
   両方ともライブになるか？

A: 共有ディスクサーバーがタイブレークする。
   ディスクサーバーはアトミックtest-and-setをサポート。
   プライマリまたはバックアップが他方が死んでいると思う場合、test-and-setを試行。
   1つだけが生きている場合、test-and-setに勝ってライブになる。
   両方が試行した場合、1つが負けて停止。

共有ディスクサーバーは信頼できる必要がある！
  ディスクサーバーがダウンしている場合、サービスはダウン
  彼らは高価な耐障害性ディスクサーバーを念頭に置いている

Q: 復旧プロセス中にバックアップがクラッシュした場合はどうなるか？

A: プライマリもバックアップも引き継ぐものがない。システムは
クラスタリングサービスによって新しいVMが開始されるまでダウンする。

Q: なぜマルチコアをサポートしないのか？

パフォーマンス（表1）
  FT/Non-FT: 印象的！
    わずかな減速
  ログ帯域幅
    ディスク読み取りレート + ネットワーク入力レートを直接反映
    18 Mbit/sが最大
  ログチャネルトラフィック数値は私には低く見える
    アプリケーションは数百メガビット/秒でディスクを読み取ることができる
    そのため彼らのアプリケーションはあまりディスク集約的ではない可能性

FTが魅力的な場合はいつか？
  重要だが低強度のサービス、例えばネームサーバー。
  ソフトウェアを変更するのが便利でないサービス。

高スループットサービスのレプリケーションはどうか？
  人々はデータベースなどにアプリケーションレベルレプリケートステートマシンを使用。
    状態はDBのみ、すべてのメモリ+ディスクではない。
    イベントはDBコマンド（putまたはget）、パケットと割り込みではない。
    読み取り専用操作などのショートカットを持つことができる。
  結果: より少ないログトラフィック、より少ない出力ルール停止。
  GFSはアプリケーションレベルレプリケーションを使用、ラボ2などと同様

まとめ:
  プライマリ-バックアップレプリケーション
    VM-FT: クリーンな例
  単一障害点なしで分断に対処する方法は？
    次の講義
  より良いパフォーマンスを得る方法は？
    アプリケーションレベルレプリケートステートマシン

----

マルチCPUサポート
  - VMware KB (#1013428) はマルチCPUサポートについて話している。VM-FTは
  レプリケートステートマシンアプローチから状態転送アプローチに切り替えた可能性があるが、
  それが真実かどうかは不明。
 - https://www.bdrsuite.com/blog/what-is-vmware-vsphere-fault-tolerance-and-how-does-it-work/#:~:text=Limited%20to%208%20vCPU%3A%20Fault,in%20the%20cluster%20is%204

https://dl.acm.org/doi/10.1145/1736020.1736031

https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=87f1459031834ee02611ff8871246d7369a4c435