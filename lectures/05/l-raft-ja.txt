# 6.5840 2025 講義 5: Raft (1)

この講義
  今日: ステートマシンレプリケーション、多数決ルール、Raftの選挙（Lab 3A）
  次回: Raftの永続化、クライアントの動作、スナップショット（Lab 3B, 3C, 3D）

*** トピック: ステートマシンレプリケーション

フォルトトレラントアプリケーション構築のポピュラーなアプローチ
  クライアントはプライマリに操作を送信、
      プライマリは順序付けしてバックアップに送信
  すべてのレプリカがすべての操作を実行
  同じ開始状態、
    同じ操作、
    同じ順序、
    決定論的であれば、
    同じ終了状態になる。
  例: VM FTでのプライマリバックアップ
    操作: 命令

プライマリが故障した場合は？

* GFSではコーディネーターが新しいプライマリを選択
* コーディネーターが故障した場合は？

レプリカに新しいプライマリを選出させることはできるか
  2つのサーバーS1とS2について考える
  両方が稼働していれば、S1が担当し、決定をS2に転送
  S2がS1がダウンしていることを検知すると、S2がコーディネーターを引き継ぐ
  何が間違いうるか？
  ネットワーク分断！スプリットブレイン！

問題: コンピュータは「サーバークラッシュ」と「ネットワーク切断」を
区別できない
  症状は同じ: ネットワーク経由のクエリに対する応答なし
  この困難は長い間克服不可能に思えた
  サーバー切り替えの決定には外部エージェント（人間）が必要に見えた
  自動化されたスキームが好ましい！

*** トピック: 多数決ルール

分断への対処の大きな洞察: 多数決投票
  奇数のサーバーを持つ、例えば3つ
  何かを行うには多数の合意が必要 -- 3つのうち2つ
  多数がなければ待機
  なぜ多数がスプリットブレインの回避に役立つか？
    多数を持てるのは最大1つの分断のみ
    2つのサーバーだけで見られた対称性を破る
  注意: 多数は全サーバー数に対して、生きているもののみではない
  注意: 多数を獲得した後に進行
    死んでいる可能性があるためそれ以上は待たない
  より一般的には2f+1は失敗したf個のサーバーを許容できる
    残りのf+1が2f+1の多数だから
    f個より多く故障（または接続不可）すると、進行できない
  しばしば「クォーラム」システムと呼ばれる

多数の重要な特性は任意の2つが交差すること
  交差部分のサーバーが以前の決定について情報を伝えることができる
  例: この期間に対して別のRaftリーダーがすでに選出されている

1990年頃に2つの分断耐性レプリケーションスキームが発明された、
  PaxosとView-Stamped Replication
  「コンセンサス」または「合意」プロトコルと呼ばれる
  過去15年間でこの技術は多くの実世界で使用されている
  Raft論文は現代技術の良い入門書

*** トピック: raftによるステートマシンレプリケーション

Raftによるステートマシンレプリケーション -- Lab 2 + 4を例として:
  [図: クライアント、3つのレプリカ、k/v層 + 状態、raft層 + ログ]
  Raftは各レプリカに含まれるライブラリ

1つのクライアントコマンドの時間図
  [C, L, F1, F2]
  クライアントはリーダーのk/v層にPut/Get「コマンド」を送信
  k/v層はStart()を呼び出してRaftを起動
    リーダーのRaft層がコマンドをログに追加
    リーダーはフォロワーにAppendEntries RPCを送信
    フォロワーはコマンドをログに追加
  リーダーは最小多数（自身を含む）からの返答を待つ
  多数がログに記録すればエントリは「コミット」される
    コミットされたものは故障があっても忘れられない
    多数 -> 次のリーダーの投票リクエストによって確認される
    リーダーは次のAppendEntriesでコミット情報を「ピギーバック」
  エントリがコミットされると、リーダーとフォロワーはコマンドを
  k/v層に渡す
    ラボでのApplyMsgとapplyCh
  リーダーはクライアントに応答を送信

なぜログが必要か？
  サービスはステートマシンの状態を保持、例: キー/値DB
    ログは同じ情報の代替表現！
    なぜ両方？
  ログはコマンドを順序付ける
    レプリカが単一の実行順序に合意するのを助ける
    リーダーがフォロワーが同一のログを持つことを保証するのを助ける
  ログはコミットされるまで暫定コマンドを保存
  ログはリーダーがフォロワーに再送信する必要がある場合にコマンドを保存
  ログはリブート後の再生のためにコマンドを永続的に保存

サーバーのログは互いの正確なレプリカか？
  いいえ: 一部のレプリカは遅れることがある
  いいえ: 一時的に異なるエントリを持つことがあることがわかる
  良いニュース:
    最終的には同一に収束する
    コミットメカニズムはサーバーが安定したエントリのみを実行することを
    保証

実装の課題:
  故障
     ネットワーク分断、失われたメッセージ、サーバークラッシュ
  並行性
     サーバー内およびサーバー間で
  結果: 多くの可能な実行と多くのコーナーケース
    多くの詳細が機能する必要 -- 図2
  今日: 新しいリーダーの選出、これらの課題を処理する必要がある

*** トピック: リーダー選出（Lab 3A）

なぜリーダーが必要か？
  すべてのレプリカが同じコマンドを同じ順序で実行することを保証
  （Paxosなど、一部の設計にはリーダーがない）

Raftはリーダーの順序に番号を付ける
  新しいリーダー -> 新しい期間
  期間は最大1つのリーダーを持つ; リーダーがいない場合もある
  番号付けはサーバーが最新のリーダーに従うのを助け、
  置き換えられたリーダーではない

Raftピアはいつリーダー選出を開始するか？
  「選挙タイムアウト」期間、現在のリーダーから何も聞こえない時
  ローカルのcurrentTermをインクリメントし、票を集めようとする
  注意: これは不要な選挙につながる可能性がある; 遅いが安全
  注意: 古いリーダーはまだ生きていてリーダーだと思っている可能性

期間内で最大1つのリーダーをどのように保証するか？
  （図2 RequestVote RPCとサーバーのルール）
  リーダーはサーバーの多数から「はい」の票を得る必要がある
  各サーバーは期間ごとに1票のみ投じることができる
    候補者なら自分に投票
    候補者でなければ最初に頼んだものに投票（図2のルール内で）
  特定の期間に対して多数の票を得ることができるサーバーは最大1つ
    -> ネットワーク分断があってもリーダーは最大1つ
    -> 一部のサーバーが故障しても選挙は成功できる
  注意: 再び、多数は全サーバー数に対して（生きているサーバーのみではない）

サーバーは新しく選出されたリーダーについてどのように学ぶか？
  リーダーはAppendEntriesハートビートを送出
    新しいより高い期間番号で
  リーダーのみがAppendEntriesを送信
    期間ごとに1つのリーダーのみ
    期間Tでの AppendEntriesを見れば、Tのリーダーが誰かわかる
  ハートビートは新しい選挙を抑制する
    リーダーは選挙タイムアウトより頻繁にハートビートを送信する必要

選挙が成功しない可能性がある2つの理由:

* サーバーの多数に到達できない
* 同時候補者が票を分割し、誰も多数を得られない

選挙が成功しない場合何が起こるか？
  ハートビートなし -> 別のタイムアウト -> 新しい期間の新しい選挙
  より高い期間が優先され、古い期間の候補者は辞退

特別な配慮なしには、投票分割により選挙はしばしば失敗する
  すべての選挙タイマーがほぼ同時に切れる可能性が高い
  すべての候補者が自分に投票
  そのため誰も他の人に投票しない！
  そのためすべてが正確に1票を得て、誰も多数を持たない

Raftはどのように投票分割を回避するか？
  各サーバーは選挙タイムアウト期間にランダムネスを追加
  [サーバーのタイムアウトが期限切れする時間の図]
  ランダムネスがサーバー間の対称性を破る
    1つが最も短いランダム遅延を選択
  次のタイムアウトが期限切れする前に選出するのに十分な時間を期待
  他のものは新しいリーダーのAppendEntriesハートビートを見て
    候補者にならない
  ランダム化された遅延はネットワークプロトコルの一般的なパターン

選挙タイムアウトをどのように選択するか？

* 少なくとも数回のハートビート間隔（ネットワークがハートビートを
  落とす場合に備えて）
  不要な選挙を避けるため、時間の無駄になる
* 1つの候補者が次が始まる前に成功できるほど十分長いランダム部分
* 故障に迅速に反応し、長い停止を避けるために十分短い
* テスターが困る前に数回の再試行を許可するのに十分短い
  テスターは選挙が5秒以下で完了することを要求

古いリーダーが新しいリーダーが選出されたことを認識していない場合？
  おそらく古いリーダーは選挙メッセージを見なかった
  おそらく古いリーダーは少数派のネットワーク分断にいる
  新しいリーダーはサーバーの多数がcurrentTermをインクリメントしたことを
  意味する
  古いリーダーはAppendEntries返答で新しい期間を見て辞退するか
  または古いリーダーは多数の返答を得ることができない
    そのため古いリーダーは新しいログエントリをコミットまたは実行しない
  したがってスプリットブレインはない
  しかし少数派は古いサーバーのAppendEntriesを受け入れることがある
    そのためログは古い期間の終わりで分岐する可能性がある

----------

Raft vs. Paxos: <https://dl.acm.org/doi/10.1145/3293611.3331595>
<https://decentralizedthoughts.github.io/2020-12-12-raft-liveness-full-omission/>
